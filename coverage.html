
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>basic: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ocrosby/go-logging/examples/basic/main.go (0.0%)</option>
				
				<option value="file1">github.com/ocrosby/go-logging/examples/custom-handlers/main.go (0.0%)</option>
				
				<option value="file2">github.com/ocrosby/go-logging/examples/di/main.go (0.0%)</option>
				
				<option value="file3">github.com/ocrosby/go-logging/examples/di/wire_gen.go (0.0%)</option>
				
				<option value="file4">github.com/ocrosby/go-logging/examples/fluent/main.go (0.0%)</option>
				
				<option value="file5">github.com/ocrosby/go-logging/examples/http-server/main.go (0.0%)</option>
				
				<option value="file6">github.com/ocrosby/go-logging/examples/new-architecture/main.go (0.0%)</option>
				
				<option value="file7">github.com/ocrosby/go-logging/examples/slog/main.go (0.0%)</option>
				
				<option value="file8">github.com/ocrosby/go-logging/pkg/logging/async_worker.go (97.9%)</option>
				
				<option value="file9">github.com/ocrosby/go-logging/pkg/logging/config.go (100.0%)</option>
				
				<option value="file10">github.com/ocrosby/go-logging/pkg/logging/config_new.go (98.5%)</option>
				
				<option value="file11">github.com/ocrosby/go-logging/pkg/logging/context_extractor.go (90.0%)</option>
				
				<option value="file12">github.com/ocrosby/go-logging/pkg/logging/factory.go (96.9%)</option>
				
				<option value="file13">github.com/ocrosby/go-logging/pkg/logging/fluent.go (90.2%)</option>
				
				<option value="file14">github.com/ocrosby/go-logging/pkg/logging/formatters.go (90.9%)</option>
				
				<option value="file15">github.com/ocrosby/go-logging/pkg/logging/handler_composition.go (28.1%)</option>
				
				<option value="file16">github.com/ocrosby/go-logging/pkg/logging/handler_interfaces.go (0.0%)</option>
				
				<option value="file17">github.com/ocrosby/go-logging/pkg/logging/handler_middleware.go (93.7%)</option>
				
				<option value="file18">github.com/ocrosby/go-logging/pkg/logging/http.go (100.0%)</option>
				
				<option value="file19">github.com/ocrosby/go-logging/pkg/logging/internal/utils.go (0.0%)</option>
				
				<option value="file20">github.com/ocrosby/go-logging/pkg/logging/level.go (80.0%)</option>
				
				<option value="file21">github.com/ocrosby/go-logging/pkg/logging/level_dispatcher.go (100.0%)</option>
				
				<option value="file22">github.com/ocrosby/go-logging/pkg/logging/middleware.go (100.0%)</option>
				
				<option value="file23">github.com/ocrosby/go-logging/pkg/logging/mocks/mock_logger.go (5.6%)</option>
				
				<option value="file24">github.com/ocrosby/go-logging/pkg/logging/mocks/mock_redactor.go (100.0%)</option>
				
				<option value="file25">github.com/ocrosby/go-logging/pkg/logging/outputs.go (58.3%)</option>
				
				<option value="file26">github.com/ocrosby/go-logging/pkg/logging/providers.go (100.0%)</option>
				
				<option value="file27">github.com/ocrosby/go-logging/pkg/logging/redactor.go (100.0%)</option>
				
				<option value="file28">github.com/ocrosby/go-logging/pkg/logging/registry.go (60.3%)</option>
				
				<option value="file29">github.com/ocrosby/go-logging/pkg/logging/trace.go (100.0%)</option>
				
				<option value="file30">github.com/ocrosby/go-logging/pkg/logging/unified_logger.go (87.8%)</option>
				
				<option value="file31">github.com/ocrosby/go-logging/pkg/logging/uuid_generator.go (91.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/ocrosby/go-logging/pkg/logging"
)

func main() <span class="cov0" title="0">{
        logger := logging.NewWithLevel(logging.InfoLevel)

        logger.Info("Application started")
        logger.Debug("This won't appear because level is INFO")
        logger.Warn("This is a warning")
        logger.Error("This is an error")

        logger = logger.WithField("service", "example-app")
        logger.Info("Logger with static field")

        logger = logger.WithFields(map[string]interface{}{
                "version": "1.0.0",
                "env":     "development",
        })
        logger.Info("Logger with multiple fields")

        ctx := logging.NewContextWithTrace()
        logger.InfoContext(ctx, "Message with trace ID from context")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "log/slog"
        "os"

        "github.com/ocrosby/go-logging/pkg/logging"
)

func main() <span class="cov0" title="0">{
        exampleMultiHandler()
        exampleHandlerBuilder()
        exampleConditionalHandler()
        exampleBufferedHandler()
        exampleMiddlewareChain()
}</span>

func exampleMultiHandler() <span class="cov0" title="0">{
        stdoutHandler := slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        })

        fileHandler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelWarn,
        })

        multiHandler := logging.NewMultiHandler(stdoutHandler, fileHandler)
        logger := logging.NewWithHandler(multiHandler)

        logger.Info("Info message - appears in stdout only")
        logger.Warn("Warning message - appears in both handlers")
        logger.Error("Error message - appears in both handlers")
}</span>

func exampleHandlerBuilder() <span class="cov0" title="0">{
        handler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        })

        builtHandler := logging.NewHandlerBuilder(handler).
                WithTimestamp().
                WithTraceContext().
                WithStaticFields(map[string]interface{}{
                        "service": "custom-handler-example",
                        "version": "1.0.0",
                }).
                Build()

        logger := logging.NewWithHandler(builtHandler)

        ctx := logging.WithTraceID(context.Background(), "trace-abc-123")
        logger.InfoContext(ctx, "Logging with handler builder")
}</span>

func exampleConditionalHandler() <span class="cov0" title="0">{
        handler := slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        })

        conditionalHandler := logging.NewConditionalHandler(handler, func(ctx context.Context, record slog.Record) bool </span><span class="cov0" title="0">{
                return record.Level &gt;= slog.LevelWarn
        }</span>)

        <span class="cov0" title="0">logger := logging.NewWithHandler(conditionalHandler)

        logger.Debug("Debug - filtered out")
        logger.Info("Info - filtered out")
        logger.Warn("Warning - logged")
        logger.Error("Error - logged")</span>
}

func exampleBufferedHandler() <span class="cov0" title="0">{
        handler := slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        })

        bufferedHandler := logging.NewBufferedHandler(handler, 5)
        logger := logging.NewWithHandler(bufferedHandler)

        logger.Info("Message 1")
        logger.Info("Message 2")
        logger.Info("Message 3")
        logger.Info("Message 4")
        logger.Info("Message 5")

        _ = bufferedHandler.Flush(context.Background())
}</span>

func exampleMiddlewareChain() <span class="cov0" title="0">{
        handler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        })

        middlewareHandler := logging.NewMiddlewareHandler(
                handler,
                logging.TimestampMiddleware(),
                logging.StaticFieldsMiddleware(map[string]interface{}{
                        "app": "example",
                }),
                logging.ContextExtractorMiddleware(logging.TraceContextExtractor()),
        )

        logger := logging.NewWithHandler(middlewareHandler)

        ctx := logging.WithTraceID(context.Background(), "trace-xyz-789")
        ctx = logging.WithRequestID(ctx, "req-123")

        logger.InfoContext(ctx, "Logging with middleware chain")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import "context"

func main() <span class="cov0" title="0">{
        logger := InitializeLogger()

        logger.Info("Application started using Wire DI")

        logger.Fluent().Info().
                Str("service", "di-example").
                Str("version", "1.0.0").
                Msg("Demonstrating dependency injection")

        ctx := context.Background()
        logger.InfoContext(ctx, "Logging with context")

        userLogger := logger.WithField("user_id", 12345)
        userLogger.Info("User-specific logging")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
        "github.com/ocrosby/go-logging/pkg/logging"
)

// Injectors from wire.go:

func InitializeLogger() logging.Logger <span class="cov0" title="0">{
        config := logging.ProvideConfig()
        redactorChainInterface := logging.ProvideRedactorChain(config)
        logger := logging.ProvideLogger(config, redactorChainInterface)
        return logger
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "errors"

        "github.com/ocrosby/go-logging/pkg/logging"
)

func main() <span class="cov0" title="0">{
        config := logging.NewConfig().
                WithLevel(logging.DebugLevel).
                WithJSONFormat().
                Build()
        redactorChain := logging.ProvideRedactorChain(config)
        logger := logging.NewStandardLogger(config, redactorChain)

        logger.Fluent().Info().
                Str("service", "fluent-example").
                Str("version", "1.0.0").
                Msg("Application started with fluent interface")

        logger.Fluent().Debug().
                Int("user_id", 12345).
                Str("username", "john_doe").
                Bool("active", true).
                Msg("User details")

        err := errors.New("connection timeout")
        logger.Fluent().Error().
                Err(err).
                Str("host", "db.example.com").
                Int("port", 5432).
                Msg("Database connection failed")

        ctx := logging.NewContextWithTrace()
        ctx = logging.WithRequestID(ctx, "req-456")

        logger.Fluent().Info().
                Ctx(ctx).
                Str("operation", "fetch_user").
                Msgf("Processing request for user %s", "john_doe")
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "fmt"
        "net/http"

        "github.com/ocrosby/go-logging/pkg/logging"
)

func main() <span class="cov0" title="0">{
        config := logging.NewConfig().
                WithLevel(logging.InfoLevel).
                WithJSONFormat().
                Build()
        redactorChain := logging.ProvideRedactorChain(config)
        logger := logging.NewStandardLogger(config, redactorChain)

        mux := http.NewServeMux()

        mux.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                logger.Fluent().Info().
                        Ctx(ctx).
                        Str("handler", "hello").
                        Msg("Handling hello request")

                fmt.Fprintf(w, "Hello, World!")
        }</span>)

        <span class="cov0" title="0">mux.HandleFunc("/user", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                logger.Fluent().Info().
                        Ctx(ctx).
                        Str("handler", "user").
                        Str("method", r.Method).
                        Msg("Handling user request")

                fmt.Fprintf(w, "User endpoint")
        }</span>)

        <span class="cov0" title="0">handler := logging.TracingMiddleware(logger)(mux)

        logger.Info("Starting server on :8080")
        if err := http.ListenAndServe(":8080", handler); err != nil </span><span class="cov0" title="0">{
                logger.Critical("Server failed: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "context"
        "os"

        "github.com/ocrosby/go-logging/pkg/logging"
)

func main() <span class="cov0" title="0">{
        // Example 1: Using the new unified logger with old-style factory methods
        logger := logging.NewWithLevel(logging.InfoLevel)

        // Core Logger interface - works with any logger
        logger.Log(logging.InfoLevel, "This uses the core Logger interface")
        logger.LogContext(context.Background(), logging.InfoLevel, "This includes context")

        // Use level-specific methods directly (now part of Logger interface)
        logger.Info("This uses the convenience Info method")
        logger.Debug("This debug message won't show (level is Info)")

        // Type assertion to access configurable methods
        if configLogger, ok := logger.(logging.ConfigurableLogger); ok </span><span class="cov0" title="0">{
                configLogger.SetLevel(logging.DebugLevel)
        }</span>

        // Use fluent interface directly (now part of Logger interface)
        <span class="cov0" title="0">logger.Fluent().Info().
                Str("service", "example").
                Int("version", 1).
                Msg("This uses the fluent interface")

        // Example 2: Using new configuration structure
        config := logging.NewLoggerConfig().
                WithLevel(logging.InfoLevel).
                WithJSONFormat().
                Build()

        jsonLogger := logging.NewWithLoggerConfig(config)

        jsonLogger.Info("This will be formatted as JSON")

        // WithField returns a Logger with level methods included
        loggerWithField := jsonLogger.WithField("user_id", 123)
        loggerWithField.Info("With structured fields")

        // Example 3: Using formatters and outputs directly
        formatterConfig := logging.NewFormatterConfig().WithJSONFormat().Build()
        formatter := logging.NewJSONFormatter(formatterConfig)

        entry := logging.LogEntry{
                Level:   logging.InfoLevel,
                Message: "Direct formatter usage",
                Fields: map[string]interface{}{
                        "component": "formatter-demo",
                },
        }

        data, err := formatter.Format(entry)
        if err == nil </span><span class="cov0" title="0">{
                output := logging.NewWriterOutput(os.Stdout)
                _ = output.Write(data)
        }</span>

        // Example 4: Using handler registry
        <span class="cov0" title="0">handlers := logging.ListHandlers()
        for _, name := range handlers </span><span class="cov0" title="0">{
                jsonLogger.Info("Available handler: %s", name)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "log/slog"
        "os"

        "github.com/ocrosby/go-logging/pkg/logging"
)

func main() <span class="cov0" title="0">{
        logger := logging.NewSlogTextLogger(logging.InfoLevel)

        logger.Info("Application started with slog backend")
        logger.Debug("This won't appear because level is INFO")
        logger.Warn("This is a warning")
        logger.Error("This is an error")

        logger = logger.WithField("service", "slog-example")
        logger.Info("Logger with static field")

        logger = logger.WithFields(map[string]interface{}{
                "version": "2.0.0",
                "env":     "production",
        })
        logger.Info("Logger with multiple fields")

        ctx := logging.NewContextWithTrace()
        logger.InfoContext(ctx, "Message with trace ID from context")

        jsonLogger := logging.NewSlogJSONLogger(logging.DebugLevel)
        jsonLogger.Debug("JSON formatted log with slog")
        jsonLogger.Info("Another JSON log")

        customHandler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level:     slog.LevelDebug,
                AddSource: true,
        })
        customLogger := logging.NewWithHandler(customHandler)
        customLogger.Info("Using custom slog handler")
        customLogger.Debug("Debug message with custom handler")

        customLogger.Fluent().Info().
                Str("user", "john_doe").
                Int("attempts", 3).
                Msg("Login attempt")
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package logging

import (
        "sync"
)

// AsyncWorker provides a unified pattern for asynchronous processing with proper shutdown.
// This extracts the common pattern used in AsyncOutput and AsyncHandler.
type AsyncWorker[T any] struct {
        queue      chan T
        done       chan struct{}
        wg         sync.WaitGroup
        closed     bool
        mu         sync.Mutex
        processor  func(T) error
        onShutdown func() error
}

// AsyncWorkerConfig configures an AsyncWorker
type AsyncWorkerConfig[T any] struct {
        QueueSize  int
        Processor  func(T) error
        OnShutdown func() error // Optional cleanup on shutdown
}

// NewAsyncWorker creates a new async worker with the specified configuration
func NewAsyncWorker[T any](config AsyncWorkerConfig[T]) *AsyncWorker[T] <span class="cov8" title="1">{
        if config.Processor == nil </span><span class="cov8" title="1">{
                panic("processor function is required")</span>
        }

        <span class="cov8" title="1">worker := &amp;AsyncWorker[T]{
                queue:      make(chan T, config.QueueSize),
                done:       make(chan struct{}),
                processor:  config.Processor,
                onShutdown: config.OnShutdown,
        }

        worker.wg.Add(1)
        go worker.run()

        return worker</span>
}

// Submit adds an item to the processing queue
func (w *AsyncWorker[T]) Submit(item T) bool <span class="cov8" title="1">{
        w.mu.Lock()
        closed := w.closed
        w.mu.Unlock()

        if closed </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">select </span>{
        case w.queue &lt;- item:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span> // Queue is full
        }
}

// SubmitBlocking adds an item to the queue, blocking if queue is full
func (w *AsyncWorker[T]) SubmitBlocking(item T) bool <span class="cov8" title="1">{
        w.mu.Lock()
        closed := w.closed
        w.mu.Unlock()

        if closed </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">w.queue &lt;- item
        return true</span>
}

// run is the main worker loop
func (w *AsyncWorker[T]) run() <span class="cov8" title="1">{
        defer w.wg.Done()

        for </span><span class="cov8" title="1">{
                select </span>{
                case item := &lt;-w.queue:<span class="cov8" title="1">
                        _ = w.processor(item)</span>
                case &lt;-w.done:<span class="cov8" title="1">
                        w.drainAndShutdown()
                        return</span>
                }
        }
}

// drainAndShutdown drains remaining items and calls shutdown callback
func (w *AsyncWorker[T]) drainAndShutdown() <span class="cov8" title="1">{
        // Drain remaining items
        for </span><span class="cov8" title="1">{
                select </span>{
                case item := &lt;-w.queue:<span class="cov8" title="1">
                        _ = w.processor(item)</span>
                default:<span class="cov8" title="1">
                        if w.onShutdown != nil </span><span class="cov8" title="1">{
                                _ = w.onShutdown()
                        }</span>
                        <span class="cov8" title="1">return</span>
                }
        }
}

// Stop gracefully shuts down the worker
func (w *AsyncWorker[T]) Stop() error <span class="cov8" title="1">{
        w.mu.Lock()
        if w.closed </span><span class="cov8" title="1">{
                w.mu.Unlock()
                return nil
        }</span>
        <span class="cov8" title="1">w.closed = true
        w.mu.Unlock()

        close(w.done)
        w.wg.Wait()
        return nil</span>
}

// IsClosed returns whether the worker is closed
func (w *AsyncWorker[T]) IsClosed() bool <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        return w.closed
}</span>

// QueueSize returns the current number of items in the queue
func (w *AsyncWorker[T]) QueueSize() int <span class="cov8" title="1">{
        return len(w.queue)
}</span>

// QueueCapacity returns the maximum capacity of the queue
func (w *AsyncWorker[T]) QueueCapacity() int <span class="cov8" title="1">{
        return cap(w.queue)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package logging

import (
        "io"
        "log/slog"
        "regexp"
)

type OutputFormat int

const (
        TextFormat OutputFormat = iota
        JSONFormat
)

// Config provides backward compatibility with the old configuration system.
// Deprecated: Use LoggerConfig for new code.
type Config struct {
        Level          Level
        Output         io.Writer
        Format         OutputFormat
        IncludeFile    bool
        IncludeTime    bool
        UseShortFile   bool
        RedactPatterns []*regexp.Regexp
        StaticFields   map[string]interface{}
        Handler        slog.Handler
        UseSlog        bool
}

// ToLoggerConfig converts old Config to new LoggerConfig structure.
func (c *Config) ToLoggerConfig() *LoggerConfig <span class="cov8" title="1">{
        return &amp;LoggerConfig{
                Core: &amp;CoreConfig{
                        Level:        c.Level,
                        StaticFields: c.StaticFields,
                },
                Formatter: &amp;FormatterConfig{
                        Format:         c.Format,
                        IncludeFile:    c.IncludeFile,
                        IncludeTime:    c.IncludeTime,
                        UseShortFile:   c.UseShortFile,
                        RedactPatterns: c.RedactPatterns,
                },
                Output: &amp;OutputConfig{
                        Writer: c.Output,
                },
                Handler: c.Handler,
                UseSlog: c.UseSlog,
        }
}</span>

type ConfigBuilder struct {
        builder *LoggerConfigBuilder
}

func NewConfig() *ConfigBuilder <span class="cov8" title="1">{
        return &amp;ConfigBuilder{
                builder: NewLoggerConfig(),
        }
}</span>

func (b *ConfigBuilder) WithLevel(level Level) *ConfigBuilder <span class="cov8" title="1">{
        b.builder.WithLevel(level)
        return b
}</span>

func (b *ConfigBuilder) WithLevelString(level string) *ConfigBuilder <span class="cov8" title="1">{
        b.builder.WithLevelString(level)
        return b
}</span>

func (b *ConfigBuilder) WithOutput(w io.Writer) *ConfigBuilder <span class="cov8" title="1">{
        b.builder.WithWriter(w)
        return b
}</span>

func (b *ConfigBuilder) WithFormat(format OutputFormat) *ConfigBuilder <span class="cov8" title="1">{
        b.builder.WithFormat(format)
        return b
}</span>

func (b *ConfigBuilder) WithJSONFormat() *ConfigBuilder <span class="cov8" title="1">{
        b.builder.WithJSONFormat()
        return b
}</span>

func (b *ConfigBuilder) WithTextFormat() *ConfigBuilder <span class="cov8" title="1">{
        b.builder.WithTextFormat()
        return b
}</span>

func (b *ConfigBuilder) IncludeFile(include bool) *ConfigBuilder <span class="cov8" title="1">{
        b.builder.config.Formatter.IncludeFile = include
        return b
}</span>

func (b *ConfigBuilder) IncludeTime(include bool) *ConfigBuilder <span class="cov8" title="1">{
        b.builder.config.Formatter.IncludeTime = include
        return b
}</span>

func (b *ConfigBuilder) UseShortFile(useShort bool) *ConfigBuilder <span class="cov8" title="1">{
        b.builder.config.Formatter.UseShortFile = useShort
        return b
}</span>

func (b *ConfigBuilder) AddRedactPattern(pattern string) *ConfigBuilder <span class="cov8" title="1">{
        if re, err := regexp.Compile(pattern); err == nil </span><span class="cov8" title="1">{
                b.builder.config.Formatter.RedactPatterns = append(b.builder.config.Formatter.RedactPatterns, re)
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (b *ConfigBuilder) AddRedactRegex(re *regexp.Regexp) *ConfigBuilder <span class="cov8" title="1">{
        b.builder.config.Formatter.RedactPatterns = append(b.builder.config.Formatter.RedactPatterns, re)
        return b
}</span>

func (b *ConfigBuilder) WithStaticField(key string, value interface{}) *ConfigBuilder <span class="cov8" title="1">{
        b.builder.config.Core.StaticFields[key] = value
        return b
}</span>

func (b *ConfigBuilder) WithStaticFields(fields map[string]interface{}) *ConfigBuilder <span class="cov8" title="1">{
        for k, v := range fields </span><span class="cov8" title="1">{
                b.builder.config.Core.StaticFields[k] = v
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (b *ConfigBuilder) WithHandler(handler slog.Handler) *ConfigBuilder <span class="cov8" title="1">{
        b.builder.WithHandler(handler)
        return b
}</span>

func (b *ConfigBuilder) UseSlog(use bool) *ConfigBuilder <span class="cov8" title="1">{
        b.builder.UseSlog(use)
        return b
}</span>

func (b *ConfigBuilder) FromEnvironment() *ConfigBuilder <span class="cov8" title="1">{
        b.builder.FromEnvironment()
        return b
}</span>

func (b *ConfigBuilder) Build() *Config <span class="cov8" title="1">{
        loggerConfig := b.builder.Build()
        return &amp;Config{
                Level:          loggerConfig.Core.Level,
                Output:         loggerConfig.Output.Writer,
                Format:         loggerConfig.Formatter.Format,
                IncludeFile:    loggerConfig.Formatter.IncludeFile,
                IncludeTime:    loggerConfig.Formatter.IncludeTime,
                UseShortFile:   loggerConfig.Formatter.UseShortFile,
                RedactPatterns: loggerConfig.Formatter.RedactPatterns,
                StaticFields:   loggerConfig.Core.StaticFields,
                Handler:        loggerConfig.Handler,
                UseSlog:        loggerConfig.UseSlog,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package logging

import (
        "io"
        "log/slog"
        "os"
        "regexp"
)

const (
        jsonFormatString = "json"
)

// CoreConfig contains the core logging configuration.
type CoreConfig struct {
        Level        Level
        StaticFields map[string]interface{}
}

// FormatterConfig contains formatting-related configuration.
type FormatterConfig struct {
        Format         OutputFormat
        IncludeFile    bool
        IncludeTime    bool
        UseShortFile   bool
        RedactPatterns []*regexp.Regexp
}

// OutputConfig contains output-related configuration.
type OutputConfig struct {
        Writer io.Writer
}

// LoggerConfig combines all configuration types.
type LoggerConfig struct {
        Core      *CoreConfig
        Formatter *FormatterConfig
        Output    *OutputConfig
        Handler   slog.Handler
        UseSlog   bool
}

// CoreConfigBuilder builds CoreConfig instances.
type CoreConfigBuilder struct {
        config *CoreConfig
}

// NewCoreConfig creates a new CoreConfigBuilder with defaults.
func NewCoreConfig() *CoreConfigBuilder <span class="cov8" title="1">{
        return &amp;CoreConfigBuilder{
                config: &amp;CoreConfig{
                        Level:        InfoLevel,
                        StaticFields: make(map[string]interface{}),
                },
        }
}</span>

func (b *CoreConfigBuilder) WithLevel(level Level) *CoreConfigBuilder <span class="cov8" title="1">{
        b.config.Level = level
        return b
}</span>

func (b *CoreConfigBuilder) WithLevelString(level string) *CoreConfigBuilder <span class="cov8" title="1">{
        if l, ok := ParseLevel(level); ok </span><span class="cov8" title="1">{
                b.config.Level = l
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (b *CoreConfigBuilder) WithStaticField(key string, value interface{}) *CoreConfigBuilder <span class="cov8" title="1">{
        b.config.StaticFields[key] = value
        return b
}</span>

func (b *CoreConfigBuilder) WithStaticFields(fields map[string]interface{}) *CoreConfigBuilder <span class="cov8" title="1">{
        for k, v := range fields </span><span class="cov8" title="1">{
                b.config.StaticFields[k] = v
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (b *CoreConfigBuilder) Build() *CoreConfig <span class="cov8" title="1">{
        return b.config
}</span>

// FormatterConfigBuilder builds FormatterConfig instances.
type FormatterConfigBuilder struct {
        config *FormatterConfig
}

// NewFormatterConfig creates a new FormatterConfigBuilder with defaults.
func NewFormatterConfig() *FormatterConfigBuilder <span class="cov8" title="1">{
        return &amp;FormatterConfigBuilder{
                config: &amp;FormatterConfig{
                        Format:         TextFormat,
                        IncludeFile:    true,
                        IncludeTime:    true,
                        UseShortFile:   true,
                        RedactPatterns: make([]*regexp.Regexp, 0),
                },
        }
}</span>

func (b *FormatterConfigBuilder) WithFormat(format OutputFormat) *FormatterConfigBuilder <span class="cov8" title="1">{
        b.config.Format = format
        return b
}</span>

func (b *FormatterConfigBuilder) WithJSONFormat() *FormatterConfigBuilder <span class="cov8" title="1">{
        b.config.Format = JSONFormat
        return b
}</span>

func (b *FormatterConfigBuilder) WithTextFormat() *FormatterConfigBuilder <span class="cov8" title="1">{
        b.config.Format = TextFormat
        return b
}</span>

func (b *FormatterConfigBuilder) IncludeFile(include bool) *FormatterConfigBuilder <span class="cov8" title="1">{
        b.config.IncludeFile = include
        return b
}</span>

func (b *FormatterConfigBuilder) IncludeTime(include bool) *FormatterConfigBuilder <span class="cov8" title="1">{
        b.config.IncludeTime = include
        return b
}</span>

func (b *FormatterConfigBuilder) UseShortFile(useShort bool) *FormatterConfigBuilder <span class="cov8" title="1">{
        b.config.UseShortFile = useShort
        return b
}</span>

func (b *FormatterConfigBuilder) AddRedactPattern(pattern string) *FormatterConfigBuilder <span class="cov8" title="1">{
        if re, err := regexp.Compile(pattern); err == nil </span><span class="cov8" title="1">{
                b.config.RedactPatterns = append(b.config.RedactPatterns, re)
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (b *FormatterConfigBuilder) AddRedactRegex(re *regexp.Regexp) *FormatterConfigBuilder <span class="cov8" title="1">{
        b.config.RedactPatterns = append(b.config.RedactPatterns, re)
        return b
}</span>

func (b *FormatterConfigBuilder) Build() *FormatterConfig <span class="cov8" title="1">{
        return b.config
}</span>

// OutputConfigBuilder builds OutputConfig instances.
type OutputConfigBuilder struct {
        config *OutputConfig
}

// NewOutputConfig creates a new OutputConfigBuilder with defaults.
func NewOutputConfig() *OutputConfigBuilder <span class="cov8" title="1">{
        return &amp;OutputConfigBuilder{
                config: &amp;OutputConfig{
                        Writer: os.Stdout,
                },
        }
}</span>

func (b *OutputConfigBuilder) WithWriter(w io.Writer) *OutputConfigBuilder <span class="cov8" title="1">{
        b.config.Writer = w
        return b
}</span>

func (b *OutputConfigBuilder) Build() *OutputConfig <span class="cov8" title="1">{
        return b.config
}</span>

// LoggerConfigBuilder builds complete LoggerConfig instances.
type LoggerConfigBuilder struct {
        config *LoggerConfig
}

// NewLoggerConfig creates a new LoggerConfigBuilder with defaults.
func NewLoggerConfig() *LoggerConfigBuilder <span class="cov8" title="1">{
        return &amp;LoggerConfigBuilder{
                config: &amp;LoggerConfig{
                        Core:      NewCoreConfig().Build(),
                        Formatter: NewFormatterConfig().Build(),
                        Output:    NewOutputConfig().Build(),
                        UseSlog:   false,
                },
        }
}</span>

func (b *LoggerConfigBuilder) WithCore(core *CoreConfig) *LoggerConfigBuilder <span class="cov8" title="1">{
        b.config.Core = core
        return b
}</span>

func (b *LoggerConfigBuilder) WithFormatter(formatter *FormatterConfig) *LoggerConfigBuilder <span class="cov8" title="1">{
        b.config.Formatter = formatter
        return b
}</span>

func (b *LoggerConfigBuilder) WithOutput(output *OutputConfig) *LoggerConfigBuilder <span class="cov8" title="1">{
        b.config.Output = output
        return b
}</span>

func (b *LoggerConfigBuilder) WithHandler(handler slog.Handler) *LoggerConfigBuilder <span class="cov8" title="1">{
        b.config.Handler = handler
        b.config.UseSlog = true
        return b
}</span>

func (b *LoggerConfigBuilder) UseSlog(use bool) *LoggerConfigBuilder <span class="cov8" title="1">{
        b.config.UseSlog = use
        return b
}</span>

func (b *LoggerConfigBuilder) FromEnvironment() *LoggerConfigBuilder <span class="cov8" title="1">{
        if level := os.Getenv("LOG_LEVEL"); level != "" </span><span class="cov8" title="1">{
                if l, ok := ParseLevel(level); ok </span><span class="cov8" title="1">{
                        b.config.Core.Level = l
                }</span>
        }
        <span class="cov8" title="1">if format := os.Getenv("LOG_FORMAT"); format == jsonFormatString </span><span class="cov0" title="0">{
                b.config.Formatter.Format = JSONFormat
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (b *LoggerConfigBuilder) Build() *LoggerConfig <span class="cov8" title="1">{
        return b.config
}</span>

// Convenience methods for backward compatibility
func (b *LoggerConfigBuilder) WithLevel(level Level) *LoggerConfigBuilder <span class="cov8" title="1">{
        b.config.Core.Level = level
        return b
}</span>

func (b *LoggerConfigBuilder) WithLevelString(level string) *LoggerConfigBuilder <span class="cov8" title="1">{
        if l, ok := ParseLevel(level); ok </span><span class="cov8" title="1">{
                b.config.Core.Level = l
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (b *LoggerConfigBuilder) WithWriter(w io.Writer) *LoggerConfigBuilder <span class="cov8" title="1">{
        b.config.Output.Writer = w
        return b
}</span>

func (b *LoggerConfigBuilder) WithFormat(format OutputFormat) *LoggerConfigBuilder <span class="cov8" title="1">{
        b.config.Formatter.Format = format
        return b
}</span>

func (b *LoggerConfigBuilder) WithJSONFormat() *LoggerConfigBuilder <span class="cov8" title="1">{
        b.config.Formatter.Format = JSONFormat
        return b
}</span>

func (b *LoggerConfigBuilder) WithTextFormat() *LoggerConfigBuilder <span class="cov8" title="1">{
        b.config.Formatter.Format = TextFormat
        return b
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package logging

import (
        "context"
        "log/slog"
)

type ContextExtractor interface {
        Extract(ctx context.Context) []slog.Attr
}

type contextExtractorFunc func(context.Context) []slog.Attr

func (f contextExtractorFunc) Extract(ctx context.Context) []slog.Attr <span class="cov8" title="1">{
        return f(ctx)
}</span>

type CompositeContextExtractor struct {
        extractors []ContextExtractor
}

func NewCompositeContextExtractor(extractors ...ContextExtractor) *CompositeContextExtractor <span class="cov8" title="1">{
        return &amp;CompositeContextExtractor{
                extractors: extractors,
        }
}</span>

func (c *CompositeContextExtractor) Extract(ctx context.Context) []slog.Attr <span class="cov8" title="1">{
        var attrs []slog.Attr
        for _, extractor := range c.extractors </span><span class="cov8" title="1">{
                attrs = append(attrs, extractor.Extract(ctx)...)
        }</span>
        <span class="cov8" title="1">return attrs</span>
}

func (c *CompositeContextExtractor) Add(extractor ContextExtractor) <span class="cov8" title="1">{
        c.extractors = append(c.extractors, extractor)
}</span>

func TraceContextExtractor() ContextExtractor <span class="cov8" title="1">{
        return contextExtractorFunc(func(ctx context.Context) []slog.Attr </span><span class="cov8" title="1">{
                var attrs []slog.Attr

                if traceID, ok := GetTraceID(ctx); ok </span><span class="cov8" title="1">{
                        attrs = append(attrs, slog.String("trace_id", traceID))
                }</span>

                <span class="cov8" title="1">if requestID, ok := GetRequestID(ctx); ok </span><span class="cov8" title="1">{
                        attrs = append(attrs, slog.String("request_id", requestID))
                }</span>

                <span class="cov8" title="1">if correlationID, ok := GetCorrelationID(ctx); ok </span><span class="cov8" title="1">{
                        attrs = append(attrs, slog.String("correlation_id", correlationID))
                }</span>

                <span class="cov8" title="1">return attrs</span>
        })
}

type ContextKey string

func CustomContextExtractor(key ContextKey, attrName string) ContextExtractor <span class="cov8" title="1">{
        return contextExtractorFunc(func(ctx context.Context) []slog.Attr </span><span class="cov8" title="1">{
                if value := ctx.Value(key); value != nil </span><span class="cov8" title="1">{
                        return []slog.Attr{slog.Any(attrName, value)}
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
}

func StringContextExtractor(key ContextKey, attrName string) ContextExtractor <span class="cov8" title="1">{
        return contextExtractorFunc(func(ctx context.Context) []slog.Attr </span><span class="cov8" title="1">{
                if value := ctx.Value(key); value != nil </span><span class="cov8" title="1">{
                        if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                                return []slog.Attr{slog.String(attrName, str)}
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
}

func IntContextExtractor(key ContextKey, attrName string) ContextExtractor <span class="cov8" title="1">{
        return contextExtractorFunc(func(ctx context.Context) []slog.Attr </span><span class="cov8" title="1">{
                if value := ctx.Value(key); value != nil </span><span class="cov8" title="1">{
                        if i, ok := value.(int); ok </span><span class="cov8" title="1">{
                                return []slog.Attr{slog.Int(attrName, i)}
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
}

func Int64ContextExtractor(key ContextKey, attrName string) ContextExtractor <span class="cov8" title="1">{
        return contextExtractorFunc(func(ctx context.Context) []slog.Attr </span><span class="cov8" title="1">{
                if value := ctx.Value(key); value != nil </span><span class="cov8" title="1">{
                        if i, ok := value.(int64); ok </span><span class="cov8" title="1">{
                                return []slog.Attr{slog.Int64(attrName, i)}
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
}

func BoolContextExtractor(key ContextKey, attrName string) ContextExtractor <span class="cov8" title="1">{
        return contextExtractorFunc(func(ctx context.Context) []slog.Attr </span><span class="cov8" title="1">{
                if value := ctx.Value(key); value != nil </span><span class="cov8" title="1">{
                        if b, ok := value.(bool); ok </span><span class="cov8" title="1">{
                                return []slog.Attr{slog.Bool(attrName, b)}
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package logging

import (
        "log/slog"
        "os"
        "sync"
)

var (
        defaultLogger Logger
        once          sync.Once
)

func GetDefaultLogger() Logger <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                config := ProvideConfig()
                redactorChain := ProvideRedactorChain(config)
                defaultLogger = ProvideLogger(config, redactorChain)
        }</span>)
        <span class="cov8" title="1">return defaultLogger</span>
}

func SetDefaultLogger(logger Logger) <span class="cov8" title="1">{
        defaultLogger = logger
}</span>

func New(options ...func(*ConfigBuilder)) Logger <span class="cov8" title="1">{
        builder := NewConfig()

        for _, option := range options </span><span class="cov8" title="1">{
                option(builder)
        }</span>

        <span class="cov8" title="1">config := builder.Build()
        redactorChain := ProvideRedactorChain(config)
        return ProvideLogger(config, redactorChain)</span>
}

// NewWithLoggerConfig creates a new logger using the new configuration structure.
func NewWithLoggerConfig(config *LoggerConfig) Logger <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = NewLoggerConfig().Build()
        }</span>
        <span class="cov8" title="1">redactorChain := ProvideRedactorChainFromLoggerConfig(config)
        return ProvideLoggerFromConfig(config, redactorChain)</span>
}

func NewFromEnvironment() Logger <span class="cov8" title="1">{
        config := NewConfig().
                FromEnvironment().
                Build()
        redactorChain := ProvideRedactorChain(config)
        return ProvideLogger(config, redactorChain)
}</span>

func NewWithLevel(level Level) Logger <span class="cov8" title="1">{
        config := NewConfig().
                WithLevel(level).
                Build()
        redactorChain := ProvideRedactorChain(config)
        return ProvideLogger(config, redactorChain)
}</span>

func NewWithLevelString(level string) Logger <span class="cov8" title="1">{
        config := NewConfig().
                WithLevelString(level).
                Build()
        redactorChain := ProvideRedactorChain(config)
        return ProvideLogger(config, redactorChain)
}</span>

func NewJSONLogger(level Level) Logger <span class="cov8" title="1">{
        config := NewConfig().
                WithLevel(level).
                WithJSONFormat().
                Build()
        redactorChain := ProvideRedactorChain(config)
        return ProvideLogger(config, redactorChain)
}</span>

func NewTextLogger(level Level) Logger <span class="cov8" title="1">{
        config := NewConfig().
                WithLevel(level).
                WithTextFormat().
                Build()
        redactorChain := ProvideRedactorChain(config)
        return ProvideLogger(config, redactorChain)
}</span>

func NewWithHandler(handler slog.Handler) Logger <span class="cov8" title="1">{
        config := NewConfig().
                WithHandler(handler).
                Build()
        redactorChain := ProvideRedactorChain(config)
        return ProvideLogger(config, redactorChain)
}</span>

func NewSlogJSONLogger(level Level) Logger <span class="cov8" title="1">{
        config := NewConfig().
                WithLevel(level).
                WithJSONFormat().
                UseSlog(true).
                Build()
        redactorChain := ProvideRedactorChain(config)
        return ProvideLogger(config, redactorChain)
}</span>

func NewSlogTextLogger(level Level) Logger <span class="cov8" title="1">{
        config := NewConfig().
                WithLevel(level).
                WithTextFormat().
                UseSlog(true).
                Build()
        redactorChain := ProvideRedactorChain(config)
        return ProvideLogger(config, redactorChain)
}</span>

func Trace(msg string, args ...interface{}) <span class="cov8" title="1">{
        logger := GetDefaultLogger()
        logger.Trace(msg, args...)
}</span>

func Debug(msg string, args ...interface{}) <span class="cov8" title="1">{
        logger := GetDefaultLogger()
        logger.Debug(msg, args...)
}</span>

func Info(msg string, args ...interface{}) <span class="cov8" title="1">{
        logger := GetDefaultLogger()
        logger.Info(msg, args...)
}</span>

func Warn(msg string, args ...interface{}) <span class="cov8" title="1">{
        logger := GetDefaultLogger()
        logger.Warn(msg, args...)
}</span>

func Error(msg string, args ...interface{}) <span class="cov8" title="1">{
        logger := GetDefaultLogger()
        logger.Error(msg, args...)
}</span>

func Critical(msg string, args ...interface{}) <span class="cov8" title="1">{
        logger := GetDefaultLogger()
        logger.Critical(msg, args...)
}</span>

func T() Logger <span class="cov8" title="1">{
        return GetDefaultLogger()
}</span>

func D() Logger <span class="cov8" title="1">{
        return GetDefaultLogger()
}</span>

func I() Logger <span class="cov8" title="1">{
        return GetDefaultLogger()
}</span>

func E() Logger <span class="cov8" title="1">{
        return GetDefaultLogger()
}</span>

func IsDebugEnabled() bool <span class="cov8" title="1">{
        return GetDefaultLogger().IsLevelEnabled(DebugLevel)
}</span>

func IsTraceEnabled() bool <span class="cov8" title="1">{
        return GetDefaultLogger().IsLevelEnabled(TraceLevel)
}</span>

func MustGetEnv(key string) string <span class="cov8" title="1">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                Critical("Required environment variable not set: %s", key)
                os.Exit(1)
        }</span>
        <span class="cov8" title="1">return value</span>
}

// NewStandardLogger creates a standard logger with the specified config and redactor chain.
// Deprecated: Use New() or NewWithLoggerConfig() for new code.
func NewStandardLogger(config *Config, redactorChain RedactorChainInterface) Logger <span class="cov8" title="1">{
        return ProvideLogger(config, redactorChain)
}</span>

// NewSlogLogger creates a slog-based logger with the specified config and redactor chain.
// Deprecated: Use New() or NewWithLoggerConfig() for new code.
func NewSlogLogger(config *Config, redactorChain RedactorChainInterface) Logger <span class="cov8" title="1">{
        return ProvideLogger(config, redactorChain)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package logging

import "context"

type fluentLoggerWrapper struct {
        logger Logger
}

func (w *fluentLoggerWrapper) createEntry(level Level) *FluentEntry <span class="cov8" title="1">{
        return &amp;FluentEntry{
                logger: w.logger,
                level:  level,
                fields: make(map[string]interface{}),
        }
}</span>

func (w *fluentLoggerWrapper) Trace() *FluentEntry <span class="cov8" title="1">{
        return w.createEntry(TraceLevel)
}</span>

func (w *fluentLoggerWrapper) Debug() *FluentEntry <span class="cov8" title="1">{
        return w.createEntry(DebugLevel)
}</span>

func (w *fluentLoggerWrapper) Info() *FluentEntry <span class="cov8" title="1">{
        return w.createEntry(InfoLevel)
}</span>

func (w *fluentLoggerWrapper) Warn() *FluentEntry <span class="cov8" title="1">{
        return w.createEntry(WarnLevel)
}</span>

func (w *fluentLoggerWrapper) Error() *FluentEntry <span class="cov8" title="1">{
        return w.createEntry(ErrorLevel)
}</span>

func (w *fluentLoggerWrapper) Critical() *FluentEntry <span class="cov8" title="1">{
        return w.createEntry(CriticalLevel)
}</span>

// FluentEntry represents a fluent logging entry that can be configured
// with structured fields before being output. Methods can be chained
// until Msg() or Msgf() is called to output the log entry.
//
// Example:
//
//        logger.Fluent().Info().
//                Str("service", "api").
//                Int("port", 8080).
//                Bool("ssl", true).
//                Msg("Server started")
type FluentEntry struct {
        logger  Logger
        level   Level
        fields  map[string]interface{}
        ctx     context.Context
        traceID string
}

// Field adds a key-value pair to the log entry and returns the entry for chaining.
func (e *FluentEntry) Field(key string, value interface{}) *FluentEntry <span class="cov8" title="1">{
        e.fields[key] = value
        return e
}</span>

// Fields adds multiple key-value pairs to the log entry and returns the entry for chaining.
func (e *FluentEntry) Fields(fields map[string]interface{}) *FluentEntry <span class="cov8" title="1">{
        for k, v := range fields </span><span class="cov8" title="1">{
                e.fields[k] = v
        }</span>
        <span class="cov8" title="1">return e</span>
}

// Str adds a string field to the log entry and returns the entry for chaining.
func (e *FluentEntry) Str(key, value string) *FluentEntry <span class="cov8" title="1">{
        e.fields[key] = value
        return e
}</span>

// Int adds an integer field to the log entry and returns the entry for chaining.
func (e *FluentEntry) Int(key string, value int) *FluentEntry <span class="cov8" title="1">{
        e.fields[key] = value
        return e
}</span>

// Int64 adds a 64-bit integer field to the log entry and returns the entry for chaining.
func (e *FluentEntry) Int64(key string, value int64) *FluentEntry <span class="cov8" title="1">{
        e.fields[key] = value
        return e
}</span>

// Bool adds a boolean field to the log entry and returns the entry for chaining.
func (e *FluentEntry) Bool(key string, value bool) *FluentEntry <span class="cov8" title="1">{
        e.fields[key] = value
        return e
}</span>

// Err adds an error field to the log entry and returns the entry for chaining.
// If err is nil, no field is added.
func (e *FluentEntry) Err(err error) *FluentEntry <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                e.fields["error"] = err.Error()
        }</span>
        <span class="cov8" title="1">return e</span>
}

// TraceID adds a trace identifier to the log entry and returns the entry for chaining.
// The trace ID will appear as "trace_id" in the output.
func (e *FluentEntry) TraceID(id string) *FluentEntry <span class="cov8" title="1">{
        e.traceID = id
        e.fields["trace_id"] = id
        return e
}</span>

// Ctx adds context information to the log entry and returns the entry for chaining.
// Automatically extracts trace_id, request_id, and correlation_id from the context if present.
//
// Example:
//
//        ctx := logging.WithTraceID(context.Background(), "trace-123")
//        logger.Fluent().Info().Ctx(ctx).Msg("Processing request")
func (e *FluentEntry) Ctx(ctx context.Context) *FluentEntry <span class="cov8" title="1">{
        e.ctx = ctx

        if traceID, ok := GetTraceID(ctx); ok </span><span class="cov8" title="1">{
                e.TraceID(traceID)
        }</span>
        <span class="cov8" title="1">if requestID, ok := GetRequestID(ctx); ok </span><span class="cov8" title="1">{
                e.fields["request_id"] = requestID
        }</span>
        <span class="cov8" title="1">if correlationID, ok := GetCorrelationID(ctx); ok </span><span class="cov8" title="1">{
                e.fields["correlation_id"] = correlationID
        }</span>

        <span class="cov8" title="1">return e</span>
}

// Msg outputs the log entry with the specified message.
// This is the terminal method that actually writes the log.
func (e *FluentEntry) Msg(msg string) <span class="cov8" title="1">{
        logger := e.logger.WithFields(e.fields)
        e.dispatch(logger, msg, nil)
}</span>

// Msgf outputs the log entry with a formatted message.
// This is the terminal method that actually writes the log.
//
// Example:
//
//        logger.Fluent().Info().
//                Str("user", username).
//                Msgf("User %s logged in at %s", username, time.Now())
func (e *FluentEntry) Msgf(format string, args ...interface{}) <span class="cov8" title="1">{
        logger := e.logger.WithFields(e.fields)
        e.dispatch(logger, format, args)
}</span>

type levelMethod func(string, ...interface{})
type contextLevelMethod func(context.Context, string, ...interface{})

var levelMethodMap = map[Level]func(Logger) levelMethod{
        TraceLevel: func(l Logger) levelMethod <span class="cov8" title="1">{
                return l.Trace
        }</span>,
        DebugLevel: func(l Logger) levelMethod <span class="cov8" title="1">{
                return l.Debug
        }</span>,
        InfoLevel: func(l Logger) levelMethod <span class="cov8" title="1">{
                return l.Info
        }</span>,
        WarnLevel: func(l Logger) levelMethod <span class="cov8" title="1">{
                return l.Warn
        }</span>,
        ErrorLevel: func(l Logger) levelMethod <span class="cov8" title="1">{
                return l.Error
        }</span>,
        CriticalLevel: func(l Logger) levelMethod <span class="cov8" title="1">{
                return l.Critical
        }</span>,
}

var contextLevelMethodMap = map[Level]func(Logger) contextLevelMethod{
        TraceLevel: func(l Logger) contextLevelMethod <span class="cov0" title="0">{
                return l.TraceContext
        }</span>,
        DebugLevel: func(l Logger) contextLevelMethod <span class="cov0" title="0">{
                return l.DebugContext
        }</span>,
        InfoLevel: func(l Logger) contextLevelMethod <span class="cov8" title="1">{
                return l.InfoContext
        }</span>,
        WarnLevel: func(l Logger) contextLevelMethod <span class="cov0" title="0">{
                return l.WarnContext
        }</span>,
        ErrorLevel: func(l Logger) contextLevelMethod <span class="cov0" title="0">{
                return l.ErrorContext
        }</span>,
        CriticalLevel: func(l Logger) contextLevelMethod <span class="cov0" title="0">{
                return l.CriticalContext
        }</span>,
}

func (e *FluentEntry) dispatch(logger Logger, format string, args []interface{}) <span class="cov8" title="1">{
        if e.ctx != nil </span><span class="cov8" title="1">{
                if methodGetter, ok := contextLevelMethodMap[e.level]; ok </span><span class="cov8" title="1">{
                        method := methodGetter(logger)
                        if args == nil </span><span class="cov8" title="1">{
                                method(e.ctx, format)
                        }</span> else<span class="cov0" title="0"> {
                                method(e.ctx, format, args...)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                if methodGetter, ok := levelMethodMap[e.level]; ok </span><span class="cov8" title="1">{
                        method := methodGetter(logger)
                        if args == nil </span><span class="cov8" title="1">{
                                method(format)
                        }</span> else<span class="cov8" title="1"> {
                                method(format, args...)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package logging

import (
        "encoding/json"
        "fmt"
        "runtime"
        "strings"
        "time"

        "github.com/ocrosby/go-logging/pkg/logging/internal"
)

// JSONFormatter formats log entries as JSON.
type JSONFormatter struct {
        config *FormatterConfig
}

// NewJSONFormatter creates a new JSON formatter.
func NewJSONFormatter(config *FormatterConfig) *JSONFormatter <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = NewFormatterConfig().WithJSONFormat().Build()
        }</span>
        <span class="cov8" title="1">return &amp;JSONFormatter{config: config}</span>
}

// Format formats a log entry as JSON bytes.
func (f *JSONFormatter) Format(entry LogEntry) ([]byte, error) <span class="cov8" title="1">{
        data := make(map[string]interface{})

        if f.config.IncludeTime </span><span class="cov8" title="1">{
                data["timestamp"] = entry.Timestamp.UTC().Format(time.RFC3339)
        }</span>

        <span class="cov8" title="1">data["level"] = entry.Level.String()
        data["message"] = f.applyRedaction(entry.Message)

        // Add fields
        for k, v := range entry.Fields </span><span class="cov8" title="1">{
                data[k] = v
        }</span>

        // Add file information if configured
        <span class="cov8" title="1">if f.config.IncludeFile &amp;&amp; (entry.File != "" || entry.Line != 0) </span><span class="cov8" title="1">{
                if entry.File == "" &amp;&amp; entry.Line == 0 </span><span class="cov0" title="0">{
                        // Try to get caller info
                        if _, file, line, ok := runtime.Caller(4); ok </span><span class="cov0" title="0">{
                                entry.File = file
                                entry.Line = line
                        }</span>
                }
                <span class="cov8" title="1">if entry.File != "" </span><span class="cov8" title="1">{
                        data["file"] = f.formatFilename(entry.File, entry.Line)
                }</span>
        }

        // Add context information
        <span class="cov8" title="1">contextFields := internal.ExtractContextFields(entry.Context)
        contextFields.AddToMap(data)

        return json.Marshal(data)</span>
}

func (f *JSONFormatter) applyRedaction(message string) string <span class="cov8" title="1">{
        return internal.ApplyRedactionPatterns(message, f.config.RedactPatterns)
}</span>

func (f *JSONFormatter) formatFilename(file string, line int) string <span class="cov8" title="1">{
        return internal.FormatFilename(file, line, f.config.UseShortFile)
}</span>

// TextFormatter formats log entries as human-readable text.
type TextFormatter struct {
        config *FormatterConfig
}

// NewTextFormatter creates a new text formatter.
func NewTextFormatter(config *FormatterConfig) *TextFormatter <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = NewFormatterConfig().WithTextFormat().Build()
        }</span>
        <span class="cov8" title="1">return &amp;TextFormatter{config: config}</span>
}

// Format formats a log entry as text bytes.
func (f *TextFormatter) Format(entry LogEntry) ([]byte, error) <span class="cov8" title="1">{
        var parts []string

        // Add timestamp if configured
        if f.config.IncludeTime </span><span class="cov8" title="1">{
                parts = append(parts, entry.Timestamp.Format("2006/01/02 15:04:05"))
        }</span>

        // Add level
        <span class="cov8" title="1">parts = append(parts, fmt.Sprintf("[%s]", strings.ToUpper(entry.Level.String())))

        // Add file information if configured
        if f.config.IncludeFile </span><span class="cov8" title="1">{
                if entry.File == "" &amp;&amp; entry.Line == 0 </span><span class="cov8" title="1">{
                        // Try to get caller info
                        if _, file, line, ok := runtime.Caller(4); ok </span><span class="cov0" title="0">{
                                entry.File = file
                                entry.Line = line
                        }</span>
                }
                <span class="cov8" title="1">if entry.File != "" </span><span class="cov8" title="1">{
                        parts = append(parts, f.formatFilename(entry.File, entry.Line))
                }</span>
        }

        // Add the main message
        <span class="cov8" title="1">message := f.applyRedaction(entry.Message)
        parts = append(parts, message)

        // Add fields if present
        if len(entry.Fields) &gt; 0 </span><span class="cov8" title="1">{
                var fieldParts []string
                for k, v := range entry.Fields </span><span class="cov8" title="1">{
                        fieldParts = append(fieldParts, fmt.Sprintf("%s=%v", k, v))
                }</span>
                <span class="cov8" title="1">parts = append(parts, fmt.Sprintf("{%s}", strings.Join(fieldParts, " ")))</span>
        }

        // Add context information if present
        <span class="cov8" title="1">contextFields := internal.ExtractContextFields(entry.Context)
        if contextText := contextFields.FormatForText(); contextText != "" </span><span class="cov0" title="0">{
                parts = append(parts, contextText)
        }</span>

        <span class="cov8" title="1">result := strings.Join(parts, " ") + "\n"
        return []byte(result), nil</span>
}

func (f *TextFormatter) applyRedaction(message string) string <span class="cov8" title="1">{
        return internal.ApplyRedactionPatterns(message, f.config.RedactPatterns)
}</span>

func (f *TextFormatter) formatFilename(file string, line int) string <span class="cov8" title="1">{
        return internal.FormatFilename(file, line, f.config.UseShortFile)
}</span>

// ConsoleFormatter provides colored output for console/terminal usage.
type ConsoleFormatter struct {
        config      *FormatterConfig
        useColors   bool
        levelColors map[Level]string
}

// NewConsoleFormatter creates a new console formatter with color support.
func NewConsoleFormatter(config *FormatterConfig, useColors bool) *ConsoleFormatter <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = NewFormatterConfig().WithTextFormat().Build()
        }</span>

        <span class="cov8" title="1">return &amp;ConsoleFormatter{
                config:    config,
                useColors: useColors,
                levelColors: map[Level]string{
                        TraceLevel:    "\033[36m", // Cyan
                        DebugLevel:    "\033[37m", // White
                        InfoLevel:     "\033[32m", // Green
                        WarnLevel:     "\033[33m", // Yellow
                        ErrorLevel:    "\033[31m", // Red
                        CriticalLevel: "\033[35m", // Magenta
                },
        }</span>
}

// Format formats a log entry with optional colors for console output.
func (f *ConsoleFormatter) Format(entry LogEntry) ([]byte, error) <span class="cov8" title="1">{
        var parts []string

        // Add timestamp if configured
        if f.config.IncludeTime </span><span class="cov8" title="1">{
                timestamp := entry.Timestamp.Format("15:04:05")
                if f.useColors </span><span class="cov8" title="1">{
                        timestamp = "\033[90m" + timestamp + "\033[0m" // Dark gray
                }</span>
                <span class="cov8" title="1">parts = append(parts, timestamp)</span>
        }

        // Add level with color
        <span class="cov8" title="1">levelStr := strings.ToUpper(entry.Level.String())
        if f.useColors </span><span class="cov8" title="1">{
                if color, exists := f.levelColors[entry.Level]; exists </span><span class="cov8" title="1">{
                        levelStr = color + levelStr + "\033[0m"
                }</span>
        }
        <span class="cov8" title="1">parts = append(parts, fmt.Sprintf("[%s]", levelStr))

        // Add the main message
        message := f.applyRedaction(entry.Message)
        parts = append(parts, message)

        // Add fields in a compact format
        if len(entry.Fields) &gt; 0 </span><span class="cov8" title="1">{
                var fieldParts []string
                for k, v := range entry.Fields </span><span class="cov8" title="1">{
                        fieldStr := fmt.Sprintf("%s=%v", k, v)
                        if f.useColors </span><span class="cov0" title="0">{
                                fieldStr = "\033[90m" + fieldStr + "\033[0m" // Dark gray
                        }</span>
                        <span class="cov8" title="1">fieldParts = append(fieldParts, fieldStr)</span>
                }
                <span class="cov8" title="1">parts = append(parts, strings.Join(fieldParts, " "))</span>
        }

        <span class="cov8" title="1">result := strings.Join(parts, " ") + "\n"
        return []byte(result), nil</span>
}

func (f *ConsoleFormatter) applyRedaction(message string) string <span class="cov8" title="1">{
        return internal.ApplyRedactionPatterns(message, f.config.RedactPatterns)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package logging

import (
        "context"
        "log/slog"
        "sync"
)

type HandlerFactory interface {
        Create(output interface{}) slog.Handler
}

type MultiHandler struct {
        handlers []slog.Handler
        mu       sync.RWMutex
}

func NewMultiHandler(handlers ...slog.Handler) *MultiHandler <span class="cov8" title="1">{
        return &amp;MultiHandler{
                handlers: handlers,
        }
}</span>

func (h *MultiHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        for _, handler := range h.handlers </span><span class="cov8" title="1">{
                if handler.Enabled(ctx, level) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (h *MultiHandler) Handle(ctx context.Context, record slog.Record) error <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        var firstErr error
        for _, handler := range h.handlers </span><span class="cov8" title="1">{
                if handler.Enabled(ctx, record.Level) </span><span class="cov8" title="1">{
                        if err := handler.Handle(ctx, record.Clone()); err != nil &amp;&amp; firstErr == nil </span><span class="cov0" title="0">{
                                firstErr = err
                        }</span>
                }
        }
        <span class="cov8" title="1">return firstErr</span>
}

func (h *MultiHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        newHandlers := make([]slog.Handler, len(h.handlers))
        for i, handler := range h.handlers </span><span class="cov8" title="1">{
                newHandlers[i] = handler.WithAttrs(attrs)
        }</span>
        <span class="cov8" title="1">return &amp;MultiHandler{handlers: newHandlers}</span>
}

func (h *MultiHandler) WithGroup(name string) slog.Handler <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        newHandlers := make([]slog.Handler, len(h.handlers))
        for i, handler := range h.handlers </span><span class="cov8" title="1">{
                newHandlers[i] = handler.WithGroup(name)
        }</span>
        <span class="cov8" title="1">return &amp;MultiHandler{handlers: newHandlers}</span>
}

func (h *MultiHandler) AddHandler(handler slog.Handler) <span class="cov8" title="1">{
        h.mu.Lock()
        defer h.mu.Unlock()
        h.handlers = append(h.handlers, handler)
}</span>

func (h *MultiHandler) RemoveHandler(handler slog.Handler) <span class="cov8" title="1">{
        h.mu.Lock()
        defer h.mu.Unlock()

        for i, hdlr := range h.handlers </span><span class="cov8" title="1">{
                if hdlr == handler </span><span class="cov8" title="1">{
                        h.handlers = append(h.handlers[:i], h.handlers[i+1:]...)
                        return
                }</span>
        }
}

type ConditionalHandler struct {
        handler   slog.Handler
        condition func(context.Context, slog.Record) bool
}

func NewConditionalHandler(handler slog.Handler, condition func(context.Context, slog.Record) bool) *ConditionalHandler <span class="cov0" title="0">{
        return &amp;ConditionalHandler{
                handler:   handler,
                condition: condition,
        }
}</span>

func (h *ConditionalHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov0" title="0">{
        return h.handler.Enabled(ctx, level)
}</span>

func (h *ConditionalHandler) Handle(ctx context.Context, record slog.Record) error <span class="cov0" title="0">{
        if h.condition != nil &amp;&amp; !h.condition(ctx, record) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return h.handler.Handle(ctx, record)</span>
}

func (h *ConditionalHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return &amp;ConditionalHandler{
                handler:   h.handler.WithAttrs(attrs),
                condition: h.condition,
        }
}</span>

func (h *ConditionalHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return &amp;ConditionalHandler{
                handler:   h.handler.WithGroup(name),
                condition: h.condition,
        }
}</span>

type BufferedHandler struct {
        handler slog.Handler
        buffer  []slog.Record
        maxSize int
        mu      sync.Mutex
        flushFn func([]slog.Record) error
}

func NewBufferedHandler(handler slog.Handler, maxSize int) *BufferedHandler <span class="cov0" title="0">{
        return &amp;BufferedHandler{
                handler: handler,
                buffer:  make([]slog.Record, 0, maxSize),
                maxSize: maxSize,
        }
}</span>

func (h *BufferedHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov0" title="0">{
        return h.handler.Enabled(ctx, level)
}</span>

func (h *BufferedHandler) Handle(ctx context.Context, record slog.Record) error <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        h.buffer = append(h.buffer, record)

        if len(h.buffer) &gt;= h.maxSize </span><span class="cov0" title="0">{
                return h.flushInternal(ctx)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *BufferedHandler) Flush(ctx context.Context) error <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()
        return h.flushInternal(ctx)
}</span>

func (h *BufferedHandler) flushInternal(ctx context.Context) error <span class="cov0" title="0">{
        if len(h.buffer) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var firstErr error
        for _, record := range h.buffer </span><span class="cov0" title="0">{
                if err := h.handler.Handle(ctx, record); err != nil &amp;&amp; firstErr == nil </span><span class="cov0" title="0">{
                        firstErr = err
                }</span>
        }

        <span class="cov0" title="0">h.buffer = h.buffer[:0]
        return firstErr</span>
}

func (h *BufferedHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return &amp;BufferedHandler{
                handler: h.handler.WithAttrs(attrs),
                buffer:  make([]slog.Record, 0, h.maxSize),
                maxSize: h.maxSize,
                flushFn: h.flushFn,
        }
}</span>

func (h *BufferedHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return &amp;BufferedHandler{
                handler: h.handler.WithGroup(name),
                buffer:  make([]slog.Record, 0, h.maxSize),
                maxSize: h.maxSize,
                flushFn: h.flushFn,
        }
}</span>

type AsyncHandler struct {
        handler slog.Handler
        worker  *AsyncWorker[slog.Record]
}

func NewAsyncHandler(handler slog.Handler, queueSize int) *AsyncHandler <span class="cov0" title="0">{
        ah := &amp;AsyncHandler{handler: handler}

        ah.worker = NewAsyncWorker(AsyncWorkerConfig[slog.Record]{
                QueueSize: queueSize,
                Processor: func(record slog.Record) error </span><span class="cov0" title="0">{
                        return ah.handler.Handle(context.Background(), record)
                }</span>,
        })

        <span class="cov0" title="0">return ah</span>
}

func (h *AsyncHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov0" title="0">{
        return h.handler.Enabled(ctx, level)
}</span>

func (h *AsyncHandler) Handle(ctx context.Context, record slog.Record) error <span class="cov0" title="0">{
        if h.worker.Submit(record) </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Queue is full, handle synchronously as fallback
        <span class="cov0" title="0">return h.handler.Handle(ctx, record)</span>
}

func (h *AsyncHandler) Close() <span class="cov0" title="0">{
        _ = h.worker.Stop()
}</span>

func (h *AsyncHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return NewAsyncHandler(h.handler.WithAttrs(attrs), h.worker.QueueCapacity())
}</span>

func (h *AsyncHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return NewAsyncHandler(h.handler.WithGroup(name), h.worker.QueueCapacity())
}</span>

type RotatingHandler struct {
        handlers []slog.Handler
        current  int
        mu       sync.Mutex
}

func NewRotatingHandler(handlers ...slog.Handler) *RotatingHandler <span class="cov0" title="0">{
        return &amp;RotatingHandler{
                handlers: handlers,
                current:  0,
        }
}</span>

func (h *RotatingHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if len(h.handlers) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return h.handlers[h.current].Enabled(ctx, level)</span>
}

func (h *RotatingHandler) Handle(ctx context.Context, record slog.Record) error <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if len(h.handlers) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">err := h.handlers[h.current].Handle(ctx, record)
        h.current = (h.current + 1) % len(h.handlers)
        return err</span>
}

func (h *RotatingHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        newHandlers := make([]slog.Handler, len(h.handlers))
        for i, handler := range h.handlers </span><span class="cov0" title="0">{
                newHandlers[i] = handler.WithAttrs(attrs)
        }</span>
        <span class="cov0" title="0">return &amp;RotatingHandler{handlers: newHandlers}</span>
}

func (h *RotatingHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        h.mu.Lock()
        defer h.mu.Unlock()

        newHandlers := make([]slog.Handler, len(h.handlers))
        for i, handler := range h.handlers </span><span class="cov0" title="0">{
                newHandlers[i] = handler.WithGroup(name)
        }</span>
        <span class="cov0" title="0">return &amp;RotatingHandler{handlers: newHandlers}</span>
}

type HandlerBuilder struct {
        handler     slog.Handler
        middlewares []HandlerMiddleware
        extractors  []ContextExtractor
}

func NewHandlerBuilder(handler slog.Handler) *HandlerBuilder <span class="cov0" title="0">{
        return &amp;HandlerBuilder{
                handler:     handler,
                middlewares: make([]HandlerMiddleware, 0),
                extractors:  make([]ContextExtractor, 0),
        }
}</span>

func (b *HandlerBuilder) WithMiddleware(middleware HandlerMiddleware) *HandlerBuilder <span class="cov0" title="0">{
        b.middlewares = append(b.middlewares, middleware)
        return b
}</span>

func (b *HandlerBuilder) WithTimestamp() *HandlerBuilder <span class="cov0" title="0">{
        return b.WithMiddleware(TimestampMiddleware())
}</span>

func (b *HandlerBuilder) WithStaticFields(fields map[string]interface{}) *HandlerBuilder <span class="cov0" title="0">{
        return b.WithMiddleware(StaticFieldsMiddleware(fields))
}</span>

func (b *HandlerBuilder) WithContextExtractor(extractor ContextExtractor) *HandlerBuilder <span class="cov0" title="0">{
        b.extractors = append(b.extractors, extractor)
        return b
}</span>

func (b *HandlerBuilder) WithTraceContext() *HandlerBuilder <span class="cov0" title="0">{
        return b.WithContextExtractor(TraceContextExtractor())
}</span>

func (b *HandlerBuilder) WithLevelFilter(minLevel slog.Level) *HandlerBuilder <span class="cov0" title="0">{
        return b.WithMiddleware(LevelFilterMiddleware(minLevel))
}</span>

func (b *HandlerBuilder) WithRedaction(redactor Redactor) *HandlerBuilder <span class="cov0" title="0">{
        return b.WithMiddleware(RedactionMiddleware(redactor))
}</span>

func (b *HandlerBuilder) WithSampling(rate int) *HandlerBuilder <span class="cov0" title="0">{
        return b.WithMiddleware(SamplingMiddleware(rate))
}</span>

func (b *HandlerBuilder) Build() slog.Handler <span class="cov0" title="0">{
        if len(b.extractors) &gt; 0 </span><span class="cov0" title="0">{
                composite := NewCompositeContextExtractor(b.extractors...)
                b.middlewares = append(b.middlewares, ContextExtractorMiddleware(composite))
        }</span>

        <span class="cov0" title="0">if len(b.middlewares) == 0 </span><span class="cov0" title="0">{
                return b.handler
        }</span>

        <span class="cov0" title="0">return NewMiddlewareHandler(b.handler, b.middlewares...)</span>
}

func MultiHandlerBuilder(handlers ...slog.Handler) *HandlerBuilder <span class="cov0" title="0">{
        return NewHandlerBuilder(NewMultiHandler(handlers...))
}</span>

func ConditionalHandlerBuilder(handler slog.Handler, condition func(context.Context, slog.Record) bool) *HandlerBuilder <span class="cov0" title="0">{
        return NewHandlerBuilder(NewConditionalHandler(handler, condition))
}</span>

func BufferedHandlerBuilder(handler slog.Handler, maxSize int) *HandlerBuilder <span class="cov0" title="0">{
        return NewHandlerBuilder(NewBufferedHandler(handler, maxSize))
}</span>

func AsyncHandlerBuilder(handler slog.Handler, queueSize int) *HandlerBuilder <span class="cov0" title="0">{
        return NewHandlerBuilder(NewAsyncHandler(handler, queueSize))
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package logging

import (
        "context"
        "log/slog"
)

// UnifiedHandlerInterface provides a consolidated interface for all handler operations.
// This combines functionality from HandlerFactory, NamedHandlerFactory, and HandlerMiddleware.
type UnifiedHandlerInterface interface {
        slog.Handler

        // Factory methods
        Create(config interface{}) (slog.Handler, error)
        Name() string
        ConfigType() interface{}

        // Middleware support
        WithMiddleware(middleware ...HandlerMiddleware) slog.Handler

        // Lifecycle management
        Close() error
}

// BaseHandler provides a foundation for implementing UnifiedHandlerInterface
type BaseHandler struct {
        name       string
        handler    slog.Handler
        middleware []HandlerMiddleware
}

// NewBaseHandler creates a new base handler
func NewBaseHandler(name string, handler slog.Handler) *BaseHandler <span class="cov0" title="0">{
        return &amp;BaseHandler{
                name:    name,
                handler: handler,
        }
}</span>

func (h *BaseHandler) Name() string <span class="cov0" title="0">{
        return h.name
}</span>

func (h *BaseHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov0" title="0">{
        return h.handler.Enabled(ctx, level)
}</span>

func (h *BaseHandler) Handle(ctx context.Context, record slog.Record) error <span class="cov0" title="0">{
        if len(h.middleware) == 0 </span><span class="cov0" title="0">{
                return h.handler.Handle(ctx, record)
        }</span>

        // Apply middleware chain
        <span class="cov0" title="0">return h.executeMiddleware(ctx, record, 0)</span>
}

func (h *BaseHandler) executeMiddleware(ctx context.Context, record slog.Record, index int) error <span class="cov0" title="0">{
        if index &gt;= len(h.middleware) </span><span class="cov0" title="0">{
                return h.handler.Handle(ctx, record)
        }</span>

        <span class="cov0" title="0">next := func(ctx context.Context, record slog.Record) error </span><span class="cov0" title="0">{
                return h.executeMiddleware(ctx, record, index+1)
        }</span>

        <span class="cov0" title="0">return h.middleware[index].Handle(ctx, record, next)</span>
}

func (h *BaseHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return &amp;BaseHandler{
                name:       h.name,
                handler:    h.handler.WithAttrs(attrs),
                middleware: h.middleware,
        }
}</span>

func (h *BaseHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return &amp;BaseHandler{
                name:       h.name,
                handler:    h.handler.WithGroup(name),
                middleware: h.middleware,
        }
}</span>

func (h *BaseHandler) WithMiddleware(middleware ...HandlerMiddleware) slog.Handler <span class="cov0" title="0">{
        newMiddleware := make([]HandlerMiddleware, len(h.middleware)+len(middleware))
        copy(newMiddleware, h.middleware)
        copy(newMiddleware[len(h.middleware):], middleware)

        return &amp;BaseHandler{
                name:       h.name,
                handler:    h.handler,
                middleware: newMiddleware,
        }
}</span>

func (h *BaseHandler) Create(config interface{}) (slog.Handler, error) <span class="cov0" title="0">{
        // Default implementation - subclasses should override
        return h, nil
}</span>

func (h *BaseHandler) ConfigType() interface{} <span class="cov0" title="0">{
        // Default implementation - subclasses should override
        return nil
}</span>

func (h *BaseHandler) Close() error <span class="cov0" title="0">{
        // Default implementation - no cleanup needed
        return nil
}</span>

// HandlerCompositor provides utilities for composing handlers
type HandlerCompositor struct {
        handlers []slog.Handler
}

// NewHandlerCompositor creates a new handler compositor
func NewHandlerCompositor() *HandlerCompositor <span class="cov0" title="0">{
        return &amp;HandlerCompositor{}
}</span>

// Add adds a handler to the composition
func (c *HandlerCompositor) Add(handler slog.Handler) *HandlerCompositor <span class="cov0" title="0">{
        c.handlers = append(c.handlers, handler)
        return c
}</span>

// Multi creates a multi-handler that writes to all composed handlers
func (c *HandlerCompositor) Multi() slog.Handler <span class="cov0" title="0">{
        return NewMultiHandler(c.handlers...)
}</span>

// Chain creates a handler chain with middleware
func (c *HandlerCompositor) Chain(middleware ...HandlerMiddleware) slog.Handler <span class="cov0" title="0">{
        if len(c.handlers) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">base := c.handlers[0]
        if bh, ok := base.(*BaseHandler); ok </span><span class="cov0" title="0">{
                return bh.WithMiddleware(middleware...)
        }</span>

        // Wrap in BaseHandler to add middleware support
        <span class="cov0" title="0">wrapped := NewBaseHandler("chained", base)
        return wrapped.WithMiddleware(middleware...)</span>
}

// HandlerType represents different types of handlers for easier management
type HandlerType int

const (
        TextHandlerType HandlerType = iota
        JSONHandlerType
        CustomHandlerType
        AsyncHandlerType
        MultiHandlerType
)

// HandlerTypeInfo provides metadata about handler types
type HandlerTypeInfo struct {
        Type        HandlerType
        Name        string
        Description string
}

var HandlerTypes = []HandlerTypeInfo{
        {TextHandlerType, "text", "Text format handler"},
        {JSONHandlerType, "json", "JSON format handler"},
        {CustomHandlerType, "custom", "Custom handler implementation"},
        {AsyncHandlerType, "async", "Asynchronous handler wrapper"},
        {MultiHandlerType, "multi", "Multiple handlers composition"},
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package logging

import (
        "context"
        "log/slog"
        "runtime"
        "time"
)

type HandlerMiddleware interface {
        Handle(ctx context.Context, record slog.Record, next HandlerFunc) error
}

type HandlerFunc func(context.Context, slog.Record) error

type handlerMiddlewareFunc func(context.Context, slog.Record, HandlerFunc) error

func (f handlerMiddlewareFunc) Handle(ctx context.Context, record slog.Record, next HandlerFunc) error <span class="cov8" title="1">{
        return f(ctx, record, next)
}</span>

type MiddlewareHandler struct {
        handler     slog.Handler
        middlewares []HandlerMiddleware
}

func NewMiddlewareHandler(handler slog.Handler, middlewares ...HandlerMiddleware) *MiddlewareHandler <span class="cov8" title="1">{
        return &amp;MiddlewareHandler{
                handler:     handler,
                middlewares: middlewares,
        }
}</span>

func (h *MiddlewareHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov0" title="0">{
        return h.handler.Enabled(ctx, level)
}</span>

func (h *MiddlewareHandler) Handle(ctx context.Context, record slog.Record) error <span class="cov8" title="1">{
        chain := h.buildChain()
        return chain(ctx, record)
}</span>

func (h *MiddlewareHandler) buildChain() HandlerFunc <span class="cov8" title="1">{
        final := func(ctx context.Context, record slog.Record) error </span><span class="cov8" title="1">{
                return h.handler.Handle(ctx, record)
        }</span>

        <span class="cov8" title="1">for i := len(h.middlewares) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                middleware := h.middlewares[i]
                next := final
                final = func(ctx context.Context, record slog.Record) error </span><span class="cov8" title="1">{
                        return middleware.Handle(ctx, record, next)
                }</span>
        }

        <span class="cov8" title="1">return final</span>
}

func (h *MiddlewareHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov8" title="1">{
        return &amp;MiddlewareHandler{
                handler:     h.handler.WithAttrs(attrs),
                middlewares: h.middlewares,
        }
}</span>

func (h *MiddlewareHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return &amp;MiddlewareHandler{
                handler:     h.handler.WithGroup(name),
                middlewares: h.middlewares,
        }
}</span>

func TimestampMiddleware() HandlerMiddleware <span class="cov8" title="1">{
        return handlerMiddlewareFunc(func(ctx context.Context, record slog.Record, next HandlerFunc) error </span><span class="cov8" title="1">{
                if record.Time.IsZero() </span><span class="cov0" title="0">{
                        record.Time = time.Now()
                }</span>
                <span class="cov8" title="1">return next(ctx, record)</span>
        })
}

func ContextExtractorMiddleware(extractor ContextExtractor) HandlerMiddleware <span class="cov8" title="1">{
        return handlerMiddlewareFunc(func(ctx context.Context, record slog.Record, next HandlerFunc) error </span><span class="cov8" title="1">{
                attrs := extractor.Extract(ctx)
                if len(attrs) &gt; 0 </span><span class="cov8" title="1">{
                        record.AddAttrs(attrs...)
                }</span>
                <span class="cov8" title="1">return next(ctx, record)</span>
        })
}

func LevelFilterMiddleware(minLevel slog.Level) HandlerMiddleware <span class="cov8" title="1">{
        return handlerMiddlewareFunc(func(ctx context.Context, record slog.Record, next HandlerFunc) error </span><span class="cov8" title="1">{
                if record.Level &lt; minLevel </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">return next(ctx, record)</span>
        })
}

func SamplingMiddleware(rate int) HandlerMiddleware <span class="cov8" title="1">{
        counter := 0
        return handlerMiddlewareFunc(func(ctx context.Context, record slog.Record, next HandlerFunc) error </span><span class="cov8" title="1">{
                counter++
                if counter%rate != 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">return next(ctx, record)</span>
        })
}

func CallerMiddleware(skip int) HandlerMiddleware <span class="cov8" title="1">{
        return handlerMiddlewareFunc(func(ctx context.Context, record slog.Record, next HandlerFunc) error </span><span class="cov8" title="1">{
                if record.PC == 0 </span><span class="cov8" title="1">{
                        record.PC = getPCs(skip + 3)
                }</span>
                <span class="cov8" title="1">return next(ctx, record)</span>
        })
}

func getPCs(skip int) uintptr <span class="cov8" title="1">{
        var pcs [1]uintptr
        n := runtime.Callers(skip+1, pcs[:])
        if n &gt; 0 </span><span class="cov8" title="1">{
                return pcs[0]
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func StaticFieldsMiddleware(fields map[string]interface{}) HandlerMiddleware <span class="cov8" title="1">{
        attrs := make([]slog.Attr, 0, len(fields))
        for k, v := range fields </span><span class="cov8" title="1">{
                attrs = append(attrs, slog.Any(k, v))
        }</span>

        <span class="cov8" title="1">return handlerMiddlewareFunc(func(ctx context.Context, record slog.Record, next HandlerFunc) error </span><span class="cov8" title="1">{
                record.AddAttrs(attrs...)
                return next(ctx, record)
        }</span>)
}

func RedactionMiddleware(redactor Redactor) HandlerMiddleware <span class="cov8" title="1">{
        return handlerMiddlewareFunc(func(ctx context.Context, record slog.Record, next HandlerFunc) error </span><span class="cov8" title="1">{
                record.Message = redactor.Redact(record.Message)
                return next(ctx, record)
        }</span>)
}

type LoggingMiddleware struct {
        onBefore func(context.Context, slog.Record)
        onAfter  func(context.Context, slog.Record, error)
}

func NewLoggingMiddleware(onBefore func(context.Context, slog.Record), onAfter func(context.Context, slog.Record, error)) HandlerMiddleware <span class="cov8" title="1">{
        return &amp;LoggingMiddleware{
                onBefore: onBefore,
                onAfter:  onAfter,
        }
}</span>

func (m *LoggingMiddleware) Handle(ctx context.Context, record slog.Record, next HandlerFunc) error <span class="cov8" title="1">{
        if m.onBefore != nil </span><span class="cov8" title="1">{
                m.onBefore(ctx, record)
        }</span>

        <span class="cov8" title="1">err := next(ctx, record)

        if m.onAfter != nil </span><span class="cov8" title="1">{
                m.onAfter(ctx, record, err)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func MetricsMiddleware(recordMetric func(level slog.Level)) HandlerMiddleware <span class="cov8" title="1">{
        return handlerMiddlewareFunc(func(ctx context.Context, record slog.Record, next HandlerFunc) error </span><span class="cov8" title="1">{
                if recordMetric != nil </span><span class="cov8" title="1">{
                        recordMetric(record.Level)
                }</span>
                <span class="cov8" title="1">return next(ctx, record)</span>
        })
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package logging

import (
        "fmt"
        "net/http"
        "strings"
)

func RedactedURL(url string, redactors ...Redactor) string <span class="cov8" title="1">{
        result := url
        if len(redactors) == 0 </span><span class="cov8" title="1">{
                return RedactAPIKeys(url)
        }</span>
        <span class="cov8" title="1">for _, redactor := range redactors </span><span class="cov8" title="1">{
                result = redactor.Redact(result)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func RequestHeaders(r *http.Request, headersToPrint []string) string <span class="cov8" title="1">{
        var sb strings.Builder

        for i, headerName := range headersToPrint </span><span class="cov8" title="1">{
                if values, ok := r.Header[headerName]; ok </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                sb.WriteString(" | ")
                        }</span>
                        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%s: %s", headerName, strings.Join(values, ", ")))</span>
                }
        }

        <span class="cov8" title="1">return sb.String()</span>
}

func GetDefaultHeaders(r *http.Request) string <span class="cov8" title="1">{
        return RequestHeaders(r, []string{"User-Agent"})
}</span>

func LogHTTPRequest(logger Logger, r *http.Request, headers ...string) <span class="cov8" title="1">{
        if len(headers) == 0 </span><span class="cov8" title="1">{
                headers = []string{"User-Agent"}
        }</span>

        <span class="cov8" title="1">url := RedactedURL(r.URL.String())
        headerStr := RequestHeaders(r, headers)

        logger.Info("HTTP Request: %s %s | Headers: %s", r.Method, url, headerStr)</span>
}

func LogHTTPResponse(logger Logger, statusCode int, url string) <span class="cov8" title="1">{
        logger.Info("HTTP Response: %d | URL: %s", statusCode, RedactedURL(url))
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package internal

import (
        "context"
        "fmt"
        "regexp"
        "strings"
)

// ContextFields represents extracted context information
type ContextFields struct {
        TraceID       string
        RequestID     string
        CorrelationID string
}

// FormatFilename formats a filename and line number for logging output
func FormatFilename(file string, line int, useShort bool) string <span class="cov0" title="0">{
        if useShort </span><span class="cov0" title="0">{
                // Extract just the filename
                if idx := strings.LastIndex(file, "/"); idx &gt;= 0 </span><span class="cov0" title="0">{
                        file = file[idx+1:]
                }</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%s:%d", file, line)</span>
}

// ApplyRedactionPatterns applies redaction patterns to a message
func ApplyRedactionPatterns(message string, patterns []*regexp.Regexp) string <span class="cov0" title="0">{
        result := message
        for _, pattern := range patterns </span><span class="cov0" title="0">{
                result = pattern.ReplaceAllString(result, "[REDACTED]")
        }</span>
        <span class="cov0" title="0">return result</span>
}

// ExtractContextFields extracts common context fields used throughout logging
func ExtractContextFields(ctx context.Context) ContextFields <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return ContextFields{}
        }</span>

        <span class="cov0" title="0">fields := ContextFields{}

        // These functions are imported from the parent package
        // We'll need to define the context key extraction logic here
        // to avoid circular imports

        // Extract trace ID using the same contextKey type as the parent package
        if val := ctx.Value(contextKey("trace_id")); val != nil </span><span class="cov0" title="0">{
                if traceID, ok := val.(string); ok </span><span class="cov0" title="0">{
                        fields.TraceID = traceID
                }</span>
        }

        // Extract request ID
        <span class="cov0" title="0">if val := ctx.Value(contextKey("request_id")); val != nil </span><span class="cov0" title="0">{
                if requestID, ok := val.(string); ok </span><span class="cov0" title="0">{
                        fields.RequestID = requestID
                }</span>
        }

        // Extract correlation ID
        <span class="cov0" title="0">if val := ctx.Value(contextKey("correlation_id")); val != nil </span><span class="cov0" title="0">{
                if correlationID, ok := val.(string); ok </span><span class="cov0" title="0">{
                        fields.CorrelationID = correlationID
                }</span>
        }

        <span class="cov0" title="0">return fields</span>
}

// Context keys (duplicated to avoid circular import)
type contextKey string

// Remove unused constants - only keep the contextKey type

// AddContextFieldsToMap adds context fields to a map for JSON/structured output
func (cf ContextFields) AddToMap(data map[string]interface{}) <span class="cov0" title="0">{
        if cf.TraceID != "" </span><span class="cov0" title="0">{
                data["trace_id"] = cf.TraceID
        }</span>
        <span class="cov0" title="0">if cf.RequestID != "" </span><span class="cov0" title="0">{
                data["request_id"] = cf.RequestID
        }</span>
        <span class="cov0" title="0">if cf.CorrelationID != "" </span><span class="cov0" title="0">{
                data["correlation_id"] = cf.CorrelationID
        }</span>
}

// FormatForText formats context fields for text output
func (cf ContextFields) FormatForText() string <span class="cov0" title="0">{
        var parts []string
        if cf.TraceID != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("trace_id=%s", cf.TraceID))
        }</span>
        <span class="cov0" title="0">if cf.RequestID != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("request_id=%s", cf.RequestID))
        }</span>
        <span class="cov0" title="0">if cf.CorrelationID != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("correlation_id=%s", cf.CorrelationID))
        }</span>

        <span class="cov0" title="0">if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("[%s]", strings.Join(parts, " "))
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// HasAnyFields returns true if any context fields are present
func (cf ContextFields) HasAnyFields() bool <span class="cov0" title="0">{
        return cf.TraceID != "" || cf.RequestID != "" || cf.CorrelationID != ""
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package logging

import "strings"

// Level represents the severity level of a log message.
// Lower numeric values indicate more verbose logging.
type Level int

const (
        // TraceLevel is the most verbose level, used for very detailed debugging.
        TraceLevel Level = iota
        // DebugLevel is used for diagnostic information useful during development.
        DebugLevel
        // InfoLevel is the default level for general informational messages.
        InfoLevel
        // WarnLevel is used for warning conditions that don't prevent operation.
        WarnLevel
        // ErrorLevel is used for error conditions that may affect functionality.
        ErrorLevel
        // CriticalLevel is the least verbose level for critical conditions requiring immediate attention.
        CriticalLevel
)

var levelNames = map[Level]string{
        TraceLevel:    "TRACE",
        DebugLevel:    "DEBUG",
        InfoLevel:     "INFO",
        WarnLevel:     "WARN",
        ErrorLevel:    "ERROR",
        CriticalLevel: "CRITICAL",
}

var nameLevels = map[string]Level{
        "TRACE":    TraceLevel,
        "DEBUG":    DebugLevel,
        "INFO":     InfoLevel,
        "WARN":     WarnLevel,
        "ERROR":    ErrorLevel,
        "CRITICAL": CriticalLevel,
}

// String returns the string representation of the log level.
// Returns "UNKNOWN" if the level is not recognized.
func (l Level) String() string <span class="cov8" title="1">{
        if name, ok := levelNames[l]; ok </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov0" title="0">return "UNKNOWN"</span>
}

// ParseLevel parses a string level name into a Level value.
// The parsing is case-insensitive. Returns the level and true if successful,
// or TraceLevel and false if the level name is not recognized.
//
// Example:
//
//        level, ok := logging.ParseLevel("INFO")
//        if !ok {
//                // handle invalid level
//        }
func ParseLevel(level string) (Level, bool) <span class="cov8" title="1">{
        l, ok := nameLevels[strings.ToUpper(level)]
        return l, ok
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package logging

import "context"

// LevelDispatcher provides a unified way to dispatch level-specific logging calls
// to the core Log and LogContext methods. This eliminates code duplication and
// provides a centralized place for level method dispatch logic.
type LevelDispatcher struct {
        logger Logger
}

// NewLevelDispatcher creates a new dispatcher for the given logger.
func NewLevelDispatcher(logger Logger) *LevelDispatcher <span class="cov8" title="1">{
        return &amp;LevelDispatcher{logger: logger}
}</span>

// DispatchTrace logs at TRACE level
func (d *LevelDispatcher) DispatchTrace(msg string, args ...interface{}) <span class="cov8" title="1">{
        d.logger.Log(TraceLevel, msg, args...)
}</span>

// DispatchDebug logs at DEBUG level
func (d *LevelDispatcher) DispatchDebug(msg string, args ...interface{}) <span class="cov8" title="1">{
        d.logger.Log(DebugLevel, msg, args...)
}</span>

// DispatchInfo logs at INFO level
func (d *LevelDispatcher) DispatchInfo(msg string, args ...interface{}) <span class="cov8" title="1">{
        d.logger.Log(InfoLevel, msg, args...)
}</span>

// DispatchWarn logs at WARN level
func (d *LevelDispatcher) DispatchWarn(msg string, args ...interface{}) <span class="cov8" title="1">{
        d.logger.Log(WarnLevel, msg, args...)
}</span>

// DispatchError logs at ERROR level
func (d *LevelDispatcher) DispatchError(msg string, args ...interface{}) <span class="cov8" title="1">{
        d.logger.Log(ErrorLevel, msg, args...)
}</span>

// DispatchCritical logs at CRITICAL level
func (d *LevelDispatcher) DispatchCritical(msg string, args ...interface{}) <span class="cov8" title="1">{
        d.logger.Log(CriticalLevel, msg, args...)
}</span>

// DispatchTraceContext logs at TRACE level with context
func (d *LevelDispatcher) DispatchTraceContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        d.logger.LogContext(ctx, TraceLevel, msg, args...)
}</span>

// DispatchDebugContext logs at DEBUG level with context
func (d *LevelDispatcher) DispatchDebugContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        d.logger.LogContext(ctx, DebugLevel, msg, args...)
}</span>

// DispatchInfoContext logs at INFO level with context
func (d *LevelDispatcher) DispatchInfoContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        d.logger.LogContext(ctx, InfoLevel, msg, args...)
}</span>

// DispatchWarnContext logs at WARN level with context
func (d *LevelDispatcher) DispatchWarnContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        d.logger.LogContext(ctx, WarnLevel, msg, args...)
}</span>

// DispatchErrorContext logs at ERROR level with context
func (d *LevelDispatcher) DispatchErrorContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        d.logger.LogContext(ctx, ErrorLevel, msg, args...)
}</span>

// DispatchCriticalContext logs at CRITICAL level with context
func (d *LevelDispatcher) DispatchCriticalContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        d.logger.LogContext(ctx, CriticalLevel, msg, args...)
}</span>

// LoggerLevelMethods provides default implementations for all level methods
// that delegate to Log/LogContext. This can be embedded in logger implementations.
type LoggerLevelMethods struct {
        dispatcher *LevelDispatcher
}

// InitLevelMethods initializes the level methods with the core logger
func (l *LoggerLevelMethods) InitLevelMethods(coreLogger Logger) <span class="cov8" title="1">{
        l.dispatcher = NewLevelDispatcher(coreLogger)
}</span>

func (l *LoggerLevelMethods) Trace(msg string, args ...interface{}) <span class="cov8" title="1">{
        l.dispatcher.DispatchTrace(msg, args...)
}</span>

func (l *LoggerLevelMethods) Debug(msg string, args ...interface{}) <span class="cov8" title="1">{
        l.dispatcher.DispatchDebug(msg, args...)
}</span>

func (l *LoggerLevelMethods) Info(msg string, args ...interface{}) <span class="cov8" title="1">{
        l.dispatcher.DispatchInfo(msg, args...)
}</span>

func (l *LoggerLevelMethods) Warn(msg string, args ...interface{}) <span class="cov8" title="1">{
        l.dispatcher.DispatchWarn(msg, args...)
}</span>

func (l *LoggerLevelMethods) Error(msg string, args ...interface{}) <span class="cov8" title="1">{
        l.dispatcher.DispatchError(msg, args...)
}</span>

func (l *LoggerLevelMethods) Critical(msg string, args ...interface{}) <span class="cov8" title="1">{
        l.dispatcher.DispatchCritical(msg, args...)
}</span>

func (l *LoggerLevelMethods) TraceContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        l.dispatcher.DispatchTraceContext(ctx, msg, args...)
}</span>

func (l *LoggerLevelMethods) DebugContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        l.dispatcher.DispatchDebugContext(ctx, msg, args...)
}</span>

func (l *LoggerLevelMethods) InfoContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        l.dispatcher.DispatchInfoContext(ctx, msg, args...)
}</span>

func (l *LoggerLevelMethods) WarnContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        l.dispatcher.DispatchWarnContext(ctx, msg, args...)
}</span>

func (l *LoggerLevelMethods) ErrorContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        l.dispatcher.DispatchErrorContext(ctx, msg, args...)
}</span>

func (l *LoggerLevelMethods) CriticalContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        l.dispatcher.DispatchCriticalContext(ctx, msg, args...)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package logging

import (
        "net/http"
        "time"
)

const (
        HeaderTraceID       = "X-Trace-ID"
        HeaderRequestID     = "X-Request-ID"
        HeaderCorrelationID = "X-Correlation-ID"
)

type responseWriter struct {
        http.ResponseWriter
        statusCode int
        written    int64
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        n, err := rw.ResponseWriter.Write(b)
        rw.written += int64(n)
        return n, err
}</span>

func TracingMiddleware(logger Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        start := time.Now()

                        ctx := r.Context()

                        traceID := r.Header.Get(HeaderTraceID)
                        if traceID == "" </span><span class="cov8" title="1">{
                                traceID = NewTraceID()
                        }</span>
                        <span class="cov8" title="1">ctx = WithTraceID(ctx, traceID)

                        requestID := r.Header.Get(HeaderRequestID)
                        if requestID != "" </span><span class="cov8" title="1">{
                                ctx = WithRequestID(ctx, requestID)
                        }</span>

                        <span class="cov8" title="1">correlationID := r.Header.Get(HeaderCorrelationID)
                        if correlationID != "" </span><span class="cov8" title="1">{
                                ctx = WithCorrelationID(ctx, correlationID)
                        }</span>

                        <span class="cov8" title="1">w.Header().Set(HeaderTraceID, traceID)

                        rw := &amp;responseWriter{
                                ResponseWriter: w,
                                statusCode:     http.StatusOK,
                        }

                        logger.Fluent().Info().
                                Ctx(ctx).
                                Str("method", r.Method).
                                Str("path", RedactedURL(r.URL.String())).
                                Str("remote_addr", r.RemoteAddr).
                                Str("user_agent", r.UserAgent()).
                                Msg("Request started")

                        next.ServeHTTP(rw, r.WithContext(ctx))

                        duration := time.Since(start)

                        logger.Fluent().Info().
                                Ctx(ctx).
                                Str("method", r.Method).
                                Str("path", RedactedURL(r.URL.String())).
                                Int("status", rw.statusCode).
                                Int64("bytes", rw.written).
                                Int64("duration_ms", duration.Milliseconds()).
                                Msg("Request completed")</span>
                })
        }
}

func RequestLogger(logger Logger, headers ...string) func(http.Handler) http.Handler <span class="cov8" title="1">{
        if len(headers) == 0 </span><span class="cov8" title="1">{
                headers = []string{"User-Agent"}
        }</span>

        <span class="cov8" title="1">return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        ctx := r.Context()

                        traceID, _ := GetTraceID(ctx)

                        entry := logger.Fluent().Info().
                                TraceID(traceID).
                                Str("method", r.Method).
                                Str("path", RedactedURL(r.URL.String())).
                                Str("headers", RequestHeaders(r, headers))
                        entry.Msg("HTTP Request")

                        next.ServeHTTP(w, r)
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/logging/logger.go
//
// Generated by this command:
//
//        mockgen -source=pkg/logging/logger.go -destination=pkg/logging/mocks/mock_logger.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        reflect "reflect"

        logging "github.com/ocrosby/go-logging/pkg/logging"
        gomock "go.uber.org/mock/gomock"
)

// MockLogger is a mock of Logger interface.
type MockLogger struct {
        ctrl     *gomock.Controller
        recorder *MockLoggerMockRecorder
        isgomock struct{}
}

// MockLoggerMockRecorder is the mock recorder for MockLogger.
type MockLoggerMockRecorder struct {
        mock *MockLogger
}

// NewMockLogger creates a new mock instance.
func NewMockLogger(ctrl *gomock.Controller) *MockLogger <span class="cov8" title="1">{
        mock := &amp;MockLogger{ctrl: ctrl}
        mock.recorder = &amp;MockLoggerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLogger) EXPECT() *MockLoggerMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Critical mocks base method.
func (m *MockLogger) Critical(msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Critical", varargs...)</span>
}

// Critical indicates an expected call of Critical.
func (mr *MockLoggerMockRecorder) Critical(msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Critical", reflect.TypeOf((*MockLogger)(nil).Critical), varargs...)
}</span>

// CriticalContext mocks base method.
func (m *MockLogger) CriticalContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "CriticalContext", varargs...)</span>
}

// CriticalContext indicates an expected call of CriticalContext.
func (mr *MockLoggerMockRecorder) CriticalContext(ctx, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CriticalContext", reflect.TypeOf((*MockLogger)(nil).CriticalContext), varargs...)
}</span>

// Debug mocks base method.
func (m *MockLogger) Debug(msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Debug", varargs...)</span>
}

// Debug indicates an expected call of Debug.
func (mr *MockLoggerMockRecorder) Debug(msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debug", reflect.TypeOf((*MockLogger)(nil).Debug), varargs...)
}</span>

// DebugContext mocks base method.
func (m *MockLogger) DebugContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "DebugContext", varargs...)</span>
}

// DebugContext indicates an expected call of DebugContext.
func (mr *MockLoggerMockRecorder) DebugContext(ctx, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DebugContext", reflect.TypeOf((*MockLogger)(nil).DebugContext), varargs...)
}</span>

// Error mocks base method.
func (m *MockLogger) Error(msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Error", varargs...)</span>
}

// Error indicates an expected call of Error.
func (mr *MockLoggerMockRecorder) Error(msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockLogger)(nil).Error), varargs...)
}</span>

// ErrorContext mocks base method.
func (m *MockLogger) ErrorContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "ErrorContext", varargs...)</span>
}

// ErrorContext indicates an expected call of ErrorContext.
func (mr *MockLoggerMockRecorder) ErrorContext(ctx, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ErrorContext", reflect.TypeOf((*MockLogger)(nil).ErrorContext), varargs...)
}</span>

// Fluent mocks base method.
func (m *MockLogger) Fluent() logging.FluentLogger <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Fluent")
        ret0, _ := ret[0].(logging.FluentLogger)
        return ret0
}</span>

// Fluent indicates an expected call of Fluent.
func (mr *MockLoggerMockRecorder) Fluent() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fluent", reflect.TypeOf((*MockLogger)(nil).Fluent))
}</span>

// GetLevel mocks base method.
func (m *MockLogger) GetLevel() logging.Level <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLevel")
        ret0, _ := ret[0].(logging.Level)
        return ret0
}</span>

// GetLevel indicates an expected call of GetLevel.
func (mr *MockLoggerMockRecorder) GetLevel() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLevel", reflect.TypeOf((*MockLogger)(nil).GetLevel))
}</span>

// Info mocks base method.
func (m *MockLogger) Info(msg string, args ...any) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">m.ctrl.Call(m, "Info", varargs...)</span>
}

// Info indicates an expected call of Info.
func (mr *MockLoggerMockRecorder) Info(msg any, args ...any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockLogger)(nil).Info), varargs...)
}</span>

// InfoContext mocks base method.
func (m *MockLogger) InfoContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "InfoContext", varargs...)</span>
}

// InfoContext indicates an expected call of InfoContext.
func (mr *MockLoggerMockRecorder) InfoContext(ctx, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InfoContext", reflect.TypeOf((*MockLogger)(nil).InfoContext), varargs...)
}</span>

// IsLevelEnabled mocks base method.
func (m *MockLogger) IsLevelEnabled(level logging.Level) bool <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsLevelEnabled", level)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsLevelEnabled indicates an expected call of IsLevelEnabled.
func (mr *MockLoggerMockRecorder) IsLevelEnabled(level any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLevelEnabled", reflect.TypeOf((*MockLogger)(nil).IsLevelEnabled), level)
}</span>

// Log mocks base method.
func (m *MockLogger) Log(level logging.Level, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{level, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Log", varargs...)</span>
}

// Log indicates an expected call of Log.
func (mr *MockLoggerMockRecorder) Log(level, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{level, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockLogger)(nil).Log), varargs...)
}</span>

// LogContext mocks base method.
func (m *MockLogger) LogContext(ctx context.Context, level logging.Level, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, level, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "LogContext", varargs...)</span>
}

// LogContext indicates an expected call of LogContext.
func (mr *MockLoggerMockRecorder) LogContext(ctx, level, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, level, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogContext", reflect.TypeOf((*MockLogger)(nil).LogContext), varargs...)
}</span>

// SetLevel mocks base method.
func (m *MockLogger) SetLevel(level logging.Level) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "SetLevel", level)
}</span>

// SetLevel indicates an expected call of SetLevel.
func (mr *MockLoggerMockRecorder) SetLevel(level any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLevel", reflect.TypeOf((*MockLogger)(nil).SetLevel), level)
}</span>

// Trace mocks base method.
func (m *MockLogger) Trace(msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Trace", varargs...)</span>
}

// Trace indicates an expected call of Trace.
func (mr *MockLoggerMockRecorder) Trace(msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Trace", reflect.TypeOf((*MockLogger)(nil).Trace), varargs...)
}</span>

// TraceContext mocks base method.
func (m *MockLogger) TraceContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "TraceContext", varargs...)</span>
}

// TraceContext indicates an expected call of TraceContext.
func (mr *MockLoggerMockRecorder) TraceContext(ctx, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TraceContext", reflect.TypeOf((*MockLogger)(nil).TraceContext), varargs...)
}</span>

// Warn mocks base method.
func (m *MockLogger) Warn(msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Warn", varargs...)</span>
}

// Warn indicates an expected call of Warn.
func (mr *MockLoggerMockRecorder) Warn(msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Warn", reflect.TypeOf((*MockLogger)(nil).Warn), varargs...)
}</span>

// WarnContext mocks base method.
func (m *MockLogger) WarnContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "WarnContext", varargs...)</span>
}

// WarnContext indicates an expected call of WarnContext.
func (mr *MockLoggerMockRecorder) WarnContext(ctx, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WarnContext", reflect.TypeOf((*MockLogger)(nil).WarnContext), varargs...)
}</span>

// WithField mocks base method.
func (m *MockLogger) WithField(key string, value any) logging.Logger <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "WithField", key, value)
        ret0, _ := ret[0].(logging.Logger)
        return ret0
}</span>

// WithField indicates an expected call of WithField.
func (mr *MockLoggerMockRecorder) WithField(key, value any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithField", reflect.TypeOf((*MockLogger)(nil).WithField), key, value)
}</span>

// WithFields mocks base method.
func (m *MockLogger) WithFields(fields map[string]any) logging.Logger <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "WithFields", fields)
        ret0, _ := ret[0].(logging.Logger)
        return ret0
}</span>

// WithFields indicates an expected call of WithFields.
func (mr *MockLoggerMockRecorder) WithFields(fields any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithFields", reflect.TypeOf((*MockLogger)(nil).WithFields), fields)
}</span>

// MockConfigurableLogger is a mock of ConfigurableLogger interface.
type MockConfigurableLogger struct {
        ctrl     *gomock.Controller
        recorder *MockConfigurableLoggerMockRecorder
        isgomock struct{}
}

// MockConfigurableLoggerMockRecorder is the mock recorder for MockConfigurableLogger.
type MockConfigurableLoggerMockRecorder struct {
        mock *MockConfigurableLogger
}

// NewMockConfigurableLogger creates a new mock instance.
func NewMockConfigurableLogger(ctrl *gomock.Controller) *MockConfigurableLogger <span class="cov0" title="0">{
        mock := &amp;MockConfigurableLogger{ctrl: ctrl}
        mock.recorder = &amp;MockConfigurableLoggerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConfigurableLogger) EXPECT() *MockConfigurableLoggerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Critical mocks base method.
func (m *MockConfigurableLogger) Critical(msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Critical", varargs...)</span>
}

// Critical indicates an expected call of Critical.
func (mr *MockConfigurableLoggerMockRecorder) Critical(msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Critical", reflect.TypeOf((*MockConfigurableLogger)(nil).Critical), varargs...)
}</span>

// CriticalContext mocks base method.
func (m *MockConfigurableLogger) CriticalContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "CriticalContext", varargs...)</span>
}

// CriticalContext indicates an expected call of CriticalContext.
func (mr *MockConfigurableLoggerMockRecorder) CriticalContext(ctx, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CriticalContext", reflect.TypeOf((*MockConfigurableLogger)(nil).CriticalContext), varargs...)
}</span>

// Debug mocks base method.
func (m *MockConfigurableLogger) Debug(msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Debug", varargs...)</span>
}

// Debug indicates an expected call of Debug.
func (mr *MockConfigurableLoggerMockRecorder) Debug(msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debug", reflect.TypeOf((*MockConfigurableLogger)(nil).Debug), varargs...)
}</span>

// DebugContext mocks base method.
func (m *MockConfigurableLogger) DebugContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "DebugContext", varargs...)</span>
}

// DebugContext indicates an expected call of DebugContext.
func (mr *MockConfigurableLoggerMockRecorder) DebugContext(ctx, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DebugContext", reflect.TypeOf((*MockConfigurableLogger)(nil).DebugContext), varargs...)
}</span>

// Error mocks base method.
func (m *MockConfigurableLogger) Error(msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Error", varargs...)</span>
}

// Error indicates an expected call of Error.
func (mr *MockConfigurableLoggerMockRecorder) Error(msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockConfigurableLogger)(nil).Error), varargs...)
}</span>

// ErrorContext mocks base method.
func (m *MockConfigurableLogger) ErrorContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "ErrorContext", varargs...)</span>
}

// ErrorContext indicates an expected call of ErrorContext.
func (mr *MockConfigurableLoggerMockRecorder) ErrorContext(ctx, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ErrorContext", reflect.TypeOf((*MockConfigurableLogger)(nil).ErrorContext), varargs...)
}</span>

// Fluent mocks base method.
func (m *MockConfigurableLogger) Fluent() logging.FluentLogger <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Fluent")
        ret0, _ := ret[0].(logging.FluentLogger)
        return ret0
}</span>

// Fluent indicates an expected call of Fluent.
func (mr *MockConfigurableLoggerMockRecorder) Fluent() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fluent", reflect.TypeOf((*MockConfigurableLogger)(nil).Fluent))
}</span>

// GetLevel mocks base method.
func (m *MockConfigurableLogger) GetLevel() logging.Level <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetLevel")
        ret0, _ := ret[0].(logging.Level)
        return ret0
}</span>

// GetLevel indicates an expected call of GetLevel.
func (mr *MockConfigurableLoggerMockRecorder) GetLevel() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLevel", reflect.TypeOf((*MockConfigurableLogger)(nil).GetLevel))
}</span>

// Info mocks base method.
func (m *MockConfigurableLogger) Info(msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Info", varargs...)</span>
}

// Info indicates an expected call of Info.
func (mr *MockConfigurableLoggerMockRecorder) Info(msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockConfigurableLogger)(nil).Info), varargs...)
}</span>

// InfoContext mocks base method.
func (m *MockConfigurableLogger) InfoContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "InfoContext", varargs...)</span>
}

// InfoContext indicates an expected call of InfoContext.
func (mr *MockConfigurableLoggerMockRecorder) InfoContext(ctx, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InfoContext", reflect.TypeOf((*MockConfigurableLogger)(nil).InfoContext), varargs...)
}</span>

// IsLevelEnabled mocks base method.
func (m *MockConfigurableLogger) IsLevelEnabled(level logging.Level) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsLevelEnabled", level)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsLevelEnabled indicates an expected call of IsLevelEnabled.
func (mr *MockConfigurableLoggerMockRecorder) IsLevelEnabled(level any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLevelEnabled", reflect.TypeOf((*MockConfigurableLogger)(nil).IsLevelEnabled), level)
}</span>

// Log mocks base method.
func (m *MockConfigurableLogger) Log(level logging.Level, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{level, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Log", varargs...)</span>
}

// Log indicates an expected call of Log.
func (mr *MockConfigurableLoggerMockRecorder) Log(level, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{level, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockConfigurableLogger)(nil).Log), varargs...)
}</span>

// LogContext mocks base method.
func (m *MockConfigurableLogger) LogContext(ctx context.Context, level logging.Level, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, level, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "LogContext", varargs...)</span>
}

// LogContext indicates an expected call of LogContext.
func (mr *MockConfigurableLoggerMockRecorder) LogContext(ctx, level, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, level, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogContext", reflect.TypeOf((*MockConfigurableLogger)(nil).LogContext), varargs...)
}</span>

// SetLevel mocks base method.
func (m *MockConfigurableLogger) SetLevel(level logging.Level) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "SetLevel", level)
}</span>

// SetLevel indicates an expected call of SetLevel.
func (mr *MockConfigurableLoggerMockRecorder) SetLevel(level any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLevel", reflect.TypeOf((*MockConfigurableLogger)(nil).SetLevel), level)
}</span>

// Trace mocks base method.
func (m *MockConfigurableLogger) Trace(msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Trace", varargs...)</span>
}

// Trace indicates an expected call of Trace.
func (mr *MockConfigurableLoggerMockRecorder) Trace(msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Trace", reflect.TypeOf((*MockConfigurableLogger)(nil).Trace), varargs...)
}</span>

// TraceContext mocks base method.
func (m *MockConfigurableLogger) TraceContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "TraceContext", varargs...)</span>
}

// TraceContext indicates an expected call of TraceContext.
func (mr *MockConfigurableLoggerMockRecorder) TraceContext(ctx, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TraceContext", reflect.TypeOf((*MockConfigurableLogger)(nil).TraceContext), varargs...)
}</span>

// Warn mocks base method.
func (m *MockConfigurableLogger) Warn(msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "Warn", varargs...)</span>
}

// Warn indicates an expected call of Warn.
func (mr *MockConfigurableLoggerMockRecorder) Warn(msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Warn", reflect.TypeOf((*MockConfigurableLogger)(nil).Warn), varargs...)
}</span>

// WarnContext mocks base method.
func (m *MockConfigurableLogger) WarnContext(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, msg}
        for _, a := range args </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "WarnContext", varargs...)</span>
}

// WarnContext indicates an expected call of WarnContext.
func (mr *MockConfigurableLoggerMockRecorder) WarnContext(ctx, msg any, args ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, msg}, args...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WarnContext", reflect.TypeOf((*MockConfigurableLogger)(nil).WarnContext), varargs...)
}</span>

// WithField mocks base method.
func (m *MockConfigurableLogger) WithField(key string, value any) logging.Logger <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "WithField", key, value)
        ret0, _ := ret[0].(logging.Logger)
        return ret0
}</span>

// WithField indicates an expected call of WithField.
func (mr *MockConfigurableLoggerMockRecorder) WithField(key, value any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithField", reflect.TypeOf((*MockConfigurableLogger)(nil).WithField), key, value)
}</span>

// WithFields mocks base method.
func (m *MockConfigurableLogger) WithFields(fields map[string]any) logging.Logger <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "WithFields", fields)
        ret0, _ := ret[0].(logging.Logger)
        return ret0
}</span>

// WithFields indicates an expected call of WithFields.
func (mr *MockConfigurableLoggerMockRecorder) WithFields(fields any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithFields", reflect.TypeOf((*MockConfigurableLogger)(nil).WithFields), fields)
}</span>

// MockFormatter is a mock of Formatter interface.
type MockFormatter struct {
        ctrl     *gomock.Controller
        recorder *MockFormatterMockRecorder
        isgomock struct{}
}

// MockFormatterMockRecorder is the mock recorder for MockFormatter.
type MockFormatterMockRecorder struct {
        mock *MockFormatter
}

// NewMockFormatter creates a new mock instance.
func NewMockFormatter(ctrl *gomock.Controller) *MockFormatter <span class="cov0" title="0">{
        mock := &amp;MockFormatter{ctrl: ctrl}
        mock.recorder = &amp;MockFormatterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFormatter) EXPECT() *MockFormatterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Format mocks base method.
func (m *MockFormatter) Format(entry logging.LogEntry) ([]byte, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Format", entry)
        ret0, _ := ret[0].([]byte)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Format indicates an expected call of Format.
func (mr *MockFormatterMockRecorder) Format(entry any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Format", reflect.TypeOf((*MockFormatter)(nil).Format), entry)
}</span>

// MockOutput is a mock of Output interface.
type MockOutput struct {
        ctrl     *gomock.Controller
        recorder *MockOutputMockRecorder
        isgomock struct{}
}

// MockOutputMockRecorder is the mock recorder for MockOutput.
type MockOutputMockRecorder struct {
        mock *MockOutput
}

// NewMockOutput creates a new mock instance.
func NewMockOutput(ctrl *gomock.Controller) *MockOutput <span class="cov0" title="0">{
        mock := &amp;MockOutput{ctrl: ctrl}
        mock.recorder = &amp;MockOutputMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOutput) EXPECT() *MockOutputMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Close mocks base method.
func (m *MockOutput) Close() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockOutputMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockOutput)(nil).Close))
}</span>

// Write mocks base method.
func (m *MockOutput) Write(data []byte) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Write", data)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Write indicates an expected call of Write.
func (mr *MockOutputMockRecorder) Write(data any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockOutput)(nil).Write), data)
}</span>

// MockBufferedOutputInterface is a mock of BufferedOutputInterface interface.
type MockBufferedOutputInterface struct {
        ctrl     *gomock.Controller
        recorder *MockBufferedOutputInterfaceMockRecorder
        isgomock struct{}
}

// MockBufferedOutputInterfaceMockRecorder is the mock recorder for MockBufferedOutputInterface.
type MockBufferedOutputInterfaceMockRecorder struct {
        mock *MockBufferedOutputInterface
}

// NewMockBufferedOutputInterface creates a new mock instance.
func NewMockBufferedOutputInterface(ctrl *gomock.Controller) *MockBufferedOutputInterface <span class="cov0" title="0">{
        mock := &amp;MockBufferedOutputInterface{ctrl: ctrl}
        mock.recorder = &amp;MockBufferedOutputInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBufferedOutputInterface) EXPECT() *MockBufferedOutputInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Close mocks base method.
func (m *MockBufferedOutputInterface) Close() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockBufferedOutputInterfaceMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockBufferedOutputInterface)(nil).Close))
}</span>

// Flush mocks base method.
func (m *MockBufferedOutputInterface) Flush() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Flush")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Flush indicates an expected call of Flush.
func (mr *MockBufferedOutputInterfaceMockRecorder) Flush() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Flush", reflect.TypeOf((*MockBufferedOutputInterface)(nil).Flush))
}</span>

// Write mocks base method.
func (m *MockBufferedOutputInterface) Write(data []byte) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Write", data)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Write indicates an expected call of Write.
func (mr *MockBufferedOutputInterfaceMockRecorder) Write(data any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockBufferedOutputInterface)(nil).Write), data)
}</span>

// MockAsyncOutputInterface is a mock of AsyncOutputInterface interface.
type MockAsyncOutputInterface struct {
        ctrl     *gomock.Controller
        recorder *MockAsyncOutputInterfaceMockRecorder
        isgomock struct{}
}

// MockAsyncOutputInterfaceMockRecorder is the mock recorder for MockAsyncOutputInterface.
type MockAsyncOutputInterfaceMockRecorder struct {
        mock *MockAsyncOutputInterface
}

// NewMockAsyncOutputInterface creates a new mock instance.
func NewMockAsyncOutputInterface(ctrl *gomock.Controller) *MockAsyncOutputInterface <span class="cov0" title="0">{
        mock := &amp;MockAsyncOutputInterface{ctrl: ctrl}
        mock.recorder = &amp;MockAsyncOutputInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAsyncOutputInterface) EXPECT() *MockAsyncOutputInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Close mocks base method.
func (m *MockAsyncOutputInterface) Close() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockAsyncOutputInterfaceMockRecorder) Close() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockAsyncOutputInterface)(nil).Close))
}</span>

// Stop mocks base method.
func (m *MockAsyncOutputInterface) Stop() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Stop")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Stop indicates an expected call of Stop.
func (mr *MockAsyncOutputInterfaceMockRecorder) Stop() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockAsyncOutputInterface)(nil).Stop))
}</span>

// Write mocks base method.
func (m *MockAsyncOutputInterface) Write(data []byte) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Write", data)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Write indicates an expected call of Write.
func (mr *MockAsyncOutputInterfaceMockRecorder) Write(data any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockAsyncOutputInterface)(nil).Write), data)
}</span>

// MockFluentLogger is a mock of FluentLogger interface.
type MockFluentLogger struct {
        ctrl     *gomock.Controller
        recorder *MockFluentLoggerMockRecorder
        isgomock struct{}
}

// MockFluentLoggerMockRecorder is the mock recorder for MockFluentLogger.
type MockFluentLoggerMockRecorder struct {
        mock *MockFluentLogger
}

// NewMockFluentLogger creates a new mock instance.
func NewMockFluentLogger(ctrl *gomock.Controller) *MockFluentLogger <span class="cov0" title="0">{
        mock := &amp;MockFluentLogger{ctrl: ctrl}
        mock.recorder = &amp;MockFluentLoggerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFluentLogger) EXPECT() *MockFluentLoggerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Critical mocks base method.
func (m *MockFluentLogger) Critical() *logging.FluentEntry <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Critical")
        ret0, _ := ret[0].(*logging.FluentEntry)
        return ret0
}</span>

// Critical indicates an expected call of Critical.
func (mr *MockFluentLoggerMockRecorder) Critical() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Critical", reflect.TypeOf((*MockFluentLogger)(nil).Critical))
}</span>

// Debug mocks base method.
func (m *MockFluentLogger) Debug() *logging.FluentEntry <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Debug")
        ret0, _ := ret[0].(*logging.FluentEntry)
        return ret0
}</span>

// Debug indicates an expected call of Debug.
func (mr *MockFluentLoggerMockRecorder) Debug() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Debug", reflect.TypeOf((*MockFluentLogger)(nil).Debug))
}</span>

// Error mocks base method.
func (m *MockFluentLogger) Error() *logging.FluentEntry <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Error")
        ret0, _ := ret[0].(*logging.FluentEntry)
        return ret0
}</span>

// Error indicates an expected call of Error.
func (mr *MockFluentLoggerMockRecorder) Error() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockFluentLogger)(nil).Error))
}</span>

// Info mocks base method.
func (m *MockFluentLogger) Info() *logging.FluentEntry <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Info")
        ret0, _ := ret[0].(*logging.FluentEntry)
        return ret0
}</span>

// Info indicates an expected call of Info.
func (mr *MockFluentLoggerMockRecorder) Info() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockFluentLogger)(nil).Info))
}</span>

// Trace mocks base method.
func (m *MockFluentLogger) Trace() *logging.FluentEntry <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Trace")
        ret0, _ := ret[0].(*logging.FluentEntry)
        return ret0
}</span>

// Trace indicates an expected call of Trace.
func (mr *MockFluentLoggerMockRecorder) Trace() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Trace", reflect.TypeOf((*MockFluentLogger)(nil).Trace))
}</span>

// Warn mocks base method.
func (m *MockFluentLogger) Warn() *logging.FluentEntry <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Warn")
        ret0, _ := ret[0].(*logging.FluentEntry)
        return ret0
}</span>

// Warn indicates an expected call of Warn.
func (mr *MockFluentLoggerMockRecorder) Warn() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Warn", reflect.TypeOf((*MockFluentLogger)(nil).Warn))
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/logging/redactor.go
//
// Generated by this command:
//
//        mockgen -source=pkg/logging/redactor.go -destination=pkg/logging/mocks/mock_redactor.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        reflect "reflect"

        logging "github.com/ocrosby/go-logging/pkg/logging"
        gomock "go.uber.org/mock/gomock"
)

// MockRedactor is a mock of Redactor interface.
type MockRedactor struct {
        ctrl     *gomock.Controller
        recorder *MockRedactorMockRecorder
        isgomock struct{}
}

// MockRedactorMockRecorder is the mock recorder for MockRedactor.
type MockRedactorMockRecorder struct {
        mock *MockRedactor
}

// NewMockRedactor creates a new mock instance.
func NewMockRedactor(ctrl *gomock.Controller) *MockRedactor <span class="cov8" title="1">{
        mock := &amp;MockRedactor{ctrl: ctrl}
        mock.recorder = &amp;MockRedactorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRedactor) EXPECT() *MockRedactorMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Redact mocks base method.
func (m *MockRedactor) Redact(input string) string <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Redact", input)
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Redact indicates an expected call of Redact.
func (mr *MockRedactorMockRecorder) Redact(input any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Redact", reflect.TypeOf((*MockRedactor)(nil).Redact), input)
}</span>

// MockRedactorChainInterface is a mock of RedactorChainInterface interface.
type MockRedactorChainInterface struct {
        ctrl     *gomock.Controller
        recorder *MockRedactorChainInterfaceMockRecorder
        isgomock struct{}
}

// MockRedactorChainInterfaceMockRecorder is the mock recorder for MockRedactorChainInterface.
type MockRedactorChainInterfaceMockRecorder struct {
        mock *MockRedactorChainInterface
}

// NewMockRedactorChainInterface creates a new mock instance.
func NewMockRedactorChainInterface(ctrl *gomock.Controller) *MockRedactorChainInterface <span class="cov8" title="1">{
        mock := &amp;MockRedactorChainInterface{ctrl: ctrl}
        mock.recorder = &amp;MockRedactorChainInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRedactorChainInterface) EXPECT() *MockRedactorChainInterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddRedactor mocks base method.
func (m *MockRedactorChainInterface) AddRedactor(redactor logging.Redactor) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "AddRedactor", redactor)
}</span>

// AddRedactor indicates an expected call of AddRedactor.
func (mr *MockRedactorChainInterfaceMockRecorder) AddRedactor(redactor any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRedactor", reflect.TypeOf((*MockRedactorChainInterface)(nil).AddRedactor), redactor)
}</span>

// Redact mocks base method.
func (m *MockRedactorChainInterface) Redact(input string) string <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Redact", input)
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// Redact indicates an expected call of Redact.
func (mr *MockRedactorChainInterfaceMockRecorder) Redact(input any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Redact", reflect.TypeOf((*MockRedactorChainInterface)(nil).Redact), input)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package logging

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
        "time"
)

// WriterOutput wraps an io.Writer to implement the Output interface.
type WriterOutput struct {
        writer io.Writer
        mu     sync.Mutex
}

// NewWriterOutput creates a new WriterOutput.
func NewWriterOutput(w io.Writer) *WriterOutput <span class="cov8" title="1">{
        return &amp;WriterOutput{writer: w}
}</span>

// Write writes data to the underlying writer.
func (o *WriterOutput) Write(data []byte) error <span class="cov8" title="1">{
        o.mu.Lock()
        defer o.mu.Unlock()
        _, err := o.writer.Write(data)
        return err
}</span>

// Close closes the output if the underlying writer implements io.Closer.
func (o *WriterOutput) Close() error <span class="cov8" title="1">{
        if closer, ok := o.writer.(io.Closer); ok </span><span class="cov8" title="1">{
                return closer.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// FileOutput writes log entries to a file.
type FileOutput struct {
        filename string
        file     *os.File
        mu       sync.Mutex
}

// NewFileOutput creates a new FileOutput that writes to the specified file.
func NewFileOutput(filename string) (*FileOutput, error) <span class="cov8" title="1">{
        // Create directory if it doesn't exist
        dir := filepath.Dir(filename)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        <span class="cov8" title="1">file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open log file: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;FileOutput{
                filename: filename,
                file:     file,
        }, nil</span>
}

// Write writes data to the file.
func (o *FileOutput) Write(data []byte) error <span class="cov8" title="1">{
        o.mu.Lock()
        defer o.mu.Unlock()

        if o.file == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("file output is closed")
        }</span>

        <span class="cov8" title="1">_, err := o.file.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to log file: %w", err)
        }</span>

        // Sync to ensure data is written to disk
        <span class="cov8" title="1">return o.file.Sync()</span>
}

// Close closes the file.
func (o *FileOutput) Close() error <span class="cov8" title="1">{
        o.mu.Lock()
        defer o.mu.Unlock()

        if o.file != nil </span><span class="cov8" title="1">{
                err := o.file.Close()
                o.file = nil
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BufferedOutput buffers writes and flushes them periodically or when full.
type BufferedOutput struct {
        output        Output
        buffer        *bufio.Writer
        bufferSize    int
        flushTimer    *time.Timer
        flushInterval time.Duration
        mu            sync.Mutex
        closed        bool
}

// NewBufferedOutput creates a new BufferedOutput with the specified buffer size and flush interval.
func NewBufferedOutput(output Output, bufferSize int, flushInterval time.Duration) *BufferedOutput <span class="cov8" title="1">{
        bo := &amp;BufferedOutput{
                output:        output,
                bufferSize:    bufferSize,
                flushInterval: flushInterval,
        }

        // Create a buffer that writes to our output
        bo.buffer = bufio.NewWriterSize(&amp;outputWriter{output: output}, bufferSize)

        // Start periodic flush timer
        if flushInterval &gt; 0 </span><span class="cov8" title="1">{
                bo.flushTimer = time.AfterFunc(flushInterval, bo.periodicFlush)
        }</span>

        <span class="cov8" title="1">return bo</span>
}

// outputWriter is a helper to make Output compatible with io.Writer
type outputWriter struct {
        output Output
}

func (ow *outputWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        err = ow.output.Write(p)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return len(p), nil</span>
}

// Write writes data to the buffer.
func (bo *BufferedOutput) Write(data []byte) error <span class="cov8" title="1">{
        bo.mu.Lock()
        defer bo.mu.Unlock()

        if bo.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("buffered output is closed")
        }</span>

        <span class="cov8" title="1">_, err := bo.buffer.Write(data)
        return err</span>
}

// Flush forces all buffered data to be written to the underlying output.
func (bo *BufferedOutput) Flush() error <span class="cov8" title="1">{
        bo.mu.Lock()
        defer bo.mu.Unlock()

        if bo.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("buffered output is closed")
        }</span>

        <span class="cov8" title="1">return bo.buffer.Flush()</span>
}

// periodicFlush is called by the timer to flush buffered data.
func (bo *BufferedOutput) periodicFlush() <span class="cov8" title="1">{
        _ = bo.Flush()

        // Restart the timer
        bo.mu.Lock()
        if !bo.closed &amp;&amp; bo.flushInterval &gt; 0 </span><span class="cov8" title="1">{
                bo.flushTimer = time.AfterFunc(bo.flushInterval, bo.periodicFlush)
        }</span>
        <span class="cov8" title="1">bo.mu.Unlock()</span>
}

// Close flushes any remaining data and closes the underlying output.
func (bo *BufferedOutput) Close() error <span class="cov8" title="1">{
        bo.mu.Lock()
        defer bo.mu.Unlock()

        if bo.closed </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">bo.closed = true

        // Stop the flush timer
        if bo.flushTimer != nil </span><span class="cov8" title="1">{
                bo.flushTimer.Stop()
        }</span>

        // Flush any remaining data
        <span class="cov8" title="1">if err := bo.buffer.Flush(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Close the underlying output
        <span class="cov8" title="1">return bo.output.Close()</span>
}

// MultiOutput writes to multiple outputs simultaneously.
type MultiOutput struct {
        outputs []Output
        mu      sync.RWMutex
}

// NewMultiOutput creates a new MultiOutput that writes to multiple outputs.
func NewMultiOutput(outputs ...Output) *MultiOutput <span class="cov8" title="1">{
        return &amp;MultiOutput{outputs: outputs}
}</span>

// Write writes data to all outputs.
func (mo *MultiOutput) Write(data []byte) error <span class="cov8" title="1">{
        mo.mu.RLock()
        defer mo.mu.RUnlock()

        var firstErr error
        for _, output := range mo.outputs </span><span class="cov8" title="1">{
                if err := output.Write(data); err != nil &amp;&amp; firstErr == nil </span><span class="cov0" title="0">{
                        firstErr = err
                }</span>
        }
        <span class="cov8" title="1">return firstErr</span>
}

// Close closes all outputs.
func (mo *MultiOutput) Close() error <span class="cov8" title="1">{
        mo.mu.Lock()
        defer mo.mu.Unlock()

        var firstErr error
        for _, output := range mo.outputs </span><span class="cov8" title="1">{
                if err := output.Close(); err != nil &amp;&amp; firstErr == nil </span><span class="cov0" title="0">{
                        firstErr = err
                }</span>
        }
        <span class="cov8" title="1">return firstErr</span>
}

// AddOutput adds a new output to the multi-output.
func (mo *MultiOutput) AddOutput(output Output) <span class="cov8" title="1">{
        mo.mu.Lock()
        defer mo.mu.Unlock()
        mo.outputs = append(mo.outputs, output)
}</span>

// RemoveOutput removes an output from the multi-output.
func (mo *MultiOutput) RemoveOutput(output Output) <span class="cov8" title="1">{
        mo.mu.Lock()
        defer mo.mu.Unlock()

        for i, o := range mo.outputs </span><span class="cov8" title="1">{
                if o == output </span><span class="cov8" title="1">{
                        mo.outputs = append(mo.outputs[:i], mo.outputs[i+1:]...)
                        return
                }</span>
        }
}

// AsyncOutput processes writes asynchronously in a background goroutine.
type AsyncOutput struct {
        output Output
        worker *AsyncWorker[[]byte]
}

// NewAsyncOutput creates a new AsyncOutput with the specified queue size.
func NewAsyncOutput(output Output, queueSize int) *AsyncOutput <span class="cov8" title="1">{
        ao := &amp;AsyncOutput{output: output}

        ao.worker = NewAsyncWorker(AsyncWorkerConfig[[]byte]{
                QueueSize: queueSize,
                Processor: func(data []byte) error </span><span class="cov8" title="1">{
                        return ao.output.Write(data)
                }</span>,
        })

        <span class="cov8" title="1">return ao</span>
}

// Write queues data for asynchronous writing.
func (ao *AsyncOutput) Write(data []byte) error <span class="cov8" title="1">{
        if ao.worker.IsClosed() </span><span class="cov0" title="0">{
                return fmt.Errorf("async output is closed")
        }</span>

        // Make a copy of the data since it might be modified by the caller
        <span class="cov8" title="1">dataCopy := make([]byte, len(data))
        copy(dataCopy, data)

        if ao.worker.Submit(dataCopy) </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Queue is full, write synchronously as fallback
        <span class="cov0" title="0">return ao.output.Write(data)</span>
}

// Stop gracefully shuts down the async processing.
func (ao *AsyncOutput) Stop() error <span class="cov8" title="1">{
        return ao.worker.Stop()
}</span>

// Close stops async processing and closes the underlying output.
func (ao *AsyncOutput) Close() error <span class="cov8" title="1">{
        if err := ao.Stop(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return ao.output.Close()</span>
}

// RotatingFileOutput writes to files with automatic rotation based on size or time.
type RotatingFileOutput struct {
        pattern     string        // File pattern with placeholders
        maxSize     int64         // Maximum size in bytes
        maxAge      time.Duration // Maximum age
        current     *os.File
        currentSize int64
        mu          sync.Mutex
}

// NewRotatingFileOutput creates a new rotating file output.
func NewRotatingFileOutput(pattern string, maxSize int64, maxAge time.Duration) *RotatingFileOutput <span class="cov0" title="0">{
        return &amp;RotatingFileOutput{
                pattern: pattern,
                maxSize: maxSize,
                maxAge:  maxAge,
        }
}</span>

// Write writes data to the current file, rotating if necessary.
func (rfo *RotatingFileOutput) Write(data []byte) error <span class="cov0" title="0">{
        rfo.mu.Lock()
        defer rfo.mu.Unlock()

        // Check if we need to rotate
        if rfo.shouldRotate(int64(len(data))) </span><span class="cov0" title="0">{
                if err := rfo.rotate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to rotate log file: %w", err)
                }</span>
        }

        // Ensure we have a current file
        <span class="cov0" title="0">if rfo.current == nil </span><span class="cov0" title="0">{
                if err := rfo.openNew(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open log file: %w", err)
                }</span>
        }

        // Write the data
        <span class="cov0" title="0">n, err := rfo.current.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to log file: %w", err)
        }</span>

        <span class="cov0" title="0">rfo.currentSize += int64(n)

        // Sync to ensure data is written
        return rfo.current.Sync()</span>
}

// shouldRotate determines if the log file should be rotated.
func (rfo *RotatingFileOutput) shouldRotate(dataSize int64) bool <span class="cov0" title="0">{
        if rfo.current == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check size limit
        <span class="cov0" title="0">if rfo.maxSize &gt; 0 &amp;&amp; rfo.currentSize+dataSize &gt; rfo.maxSize </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check age limit (simplified - would need to track file creation time)
        <span class="cov0" title="0">if rfo.maxAge &gt; 0 </span><span class="cov0" title="0">{
                if stat, err := rfo.current.Stat(); err == nil </span><span class="cov0" title="0">{
                        if time.Since(stat.ModTime()) &gt; rfo.maxAge </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// rotate closes the current file and prepares for a new one.
func (rfo *RotatingFileOutput) rotate() error <span class="cov0" title="0">{
        if rfo.current != nil </span><span class="cov0" title="0">{
                if err := rfo.current.Close(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">rfo.current = nil
                rfo.currentSize = 0</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// openNew opens a new log file.
func (rfo *RotatingFileOutput) openNew() error <span class="cov0" title="0">{
        // Generate filename from pattern (simplified)
        filename := rfo.generateFilename()

        // Create directory if it doesn't exist
        dir := filepath.Dir(filename)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        <span class="cov0" title="0">file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open log file: %w", err)
        }</span>

        <span class="cov0" title="0">rfo.current = file

        // Get current size if file already exists
        if stat, err := file.Stat(); err == nil </span><span class="cov0" title="0">{
                rfo.currentSize = stat.Size()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateFilename generates a filename from the pattern.
func (rfo *RotatingFileOutput) generateFilename() string <span class="cov0" title="0">{
        // Simple implementation - replace placeholders with current timestamp
        now := time.Now()
        filename := rfo.pattern

        // Replace common placeholders
        filename = fmt.Sprintf(filename, now.Format("2006-01-02-15-04-05"))

        return filename
}</span>

// Close closes the current file.
func (rfo *RotatingFileOutput) Close() error <span class="cov0" title="0">{
        rfo.mu.Lock()
        defer rfo.mu.Unlock()

        if rfo.current != nil </span><span class="cov0" title="0">{
                err := rfo.current.Close()
                rfo.current = nil
                rfo.currentSize = 0
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package logging

import (
        "io"
        "os"
        "regexp"
)

// Legacy providers for backward compatibility with old Config type
func ProvideConfig() *Config <span class="cov8" title="1">{
        // Convert new LoggerConfig to old Config format for backward compatibility
        newConfig := NewLoggerConfig().FromEnvironment().Build()
        return &amp;Config{
                Level:          newConfig.Core.Level,
                Output:         newConfig.Output.Writer,
                Format:         newConfig.Formatter.Format,
                IncludeFile:    newConfig.Formatter.IncludeFile,
                IncludeTime:    newConfig.Formatter.IncludeTime,
                UseShortFile:   newConfig.Formatter.UseShortFile,
                RedactPatterns: newConfig.Formatter.RedactPatterns,
                StaticFields:   newConfig.Core.StaticFields,
                Handler:        newConfig.Handler,
                UseSlog:        newConfig.UseSlog,
        }
}</span>

func ProvideConfigWithLevel(level Level) *Config <span class="cov8" title="1">{
        // Convert new LoggerConfig to old Config format for backward compatibility
        newConfig := NewLoggerConfig().WithLevel(level).FromEnvironment().Build()
        return &amp;Config{
                Level:          newConfig.Core.Level,
                Output:         newConfig.Output.Writer,
                Format:         newConfig.Formatter.Format,
                IncludeFile:    newConfig.Formatter.IncludeFile,
                IncludeTime:    newConfig.Formatter.IncludeTime,
                UseShortFile:   newConfig.Formatter.UseShortFile,
                RedactPatterns: newConfig.Formatter.RedactPatterns,
                StaticFields:   newConfig.Core.StaticFields,
                Handler:        newConfig.Handler,
                UseSlog:        newConfig.UseSlog,
        }
}</span>

// New providers using new config structure
func ProvideLoggerConfig() *LoggerConfig <span class="cov8" title="1">{
        return NewLoggerConfig().
                FromEnvironment().
                Build()
}</span>

func ProvideLoggerConfigWithLevel(level Level) *LoggerConfig <span class="cov8" title="1">{
        return NewLoggerConfig().
                WithLevel(level).
                FromEnvironment().
                Build()
}</span>

func ProvideOutput() io.Writer <span class="cov8" title="1">{
        return os.Stdout
}</span>

func ProvideRedactorChain(config *Config) RedactorChainInterface <span class="cov8" title="1">{
        return NewRedactorChain(config.RedactPatterns...)
}</span>

func ProvideRedactorChainWithPatterns(patterns ...*regexp.Regexp) RedactorChainInterface <span class="cov8" title="1">{
        return NewRedactorChain(patterns...)
}</span>

func ProvideRedactorChainFromLoggerConfig(config *LoggerConfig) RedactorChainInterface <span class="cov8" title="1">{
        return NewRedactorChain(config.Formatter.RedactPatterns...)
}</span>

// Updated provider using unified logger
func ProvideLogger(config *Config, redactorChain RedactorChainInterface) Logger <span class="cov8" title="1">{
        // Convert old config to new config format
        loggerConfig := &amp;LoggerConfig{
                Core: &amp;CoreConfig{
                        Level:        config.Level,
                        StaticFields: config.StaticFields,
                },
                Formatter: &amp;FormatterConfig{
                        Format:         config.Format,
                        IncludeFile:    config.IncludeFile,
                        IncludeTime:    config.IncludeTime,
                        UseShortFile:   config.UseShortFile,
                        RedactPatterns: config.RedactPatterns,
                },
                Output: &amp;OutputConfig{
                        Writer: config.Output,
                },
                Handler: config.Handler,
                UseSlog: config.UseSlog,
        }

        return NewUnifiedLogger(loggerConfig, redactorChain)
}</span>

// New provider using new config structure
func ProvideLoggerFromConfig(config *LoggerConfig, redactorChain RedactorChainInterface) Logger <span class="cov8" title="1">{
        return NewUnifiedLogger(config, redactorChain)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package logging

import "regexp"

type Redactor interface {
        Redact(input string) string
}

type RedactorChainInterface interface {
        AddRedactor(redactor Redactor)
        Redact(input string) string
}

type RegexRedactor struct {
        pattern     *regexp.Regexp
        replacement string
}

func NewRegexRedactor(pattern *regexp.Regexp, replacement string) *RegexRedactor <span class="cov8" title="1">{
        return &amp;RegexRedactor{
                pattern:     pattern,
                replacement: replacement,
        }
}</span>

func (r *RegexRedactor) Redact(input string) string <span class="cov8" title="1">{
        return r.pattern.ReplaceAllString(input, r.replacement)
}</span>

type RedactorChain struct {
        redactors []Redactor
}

func NewRedactorChain(patterns ...*regexp.Regexp) *RedactorChain <span class="cov8" title="1">{
        redactors := make([]Redactor, len(patterns))
        for i, pattern := range patterns </span><span class="cov8" title="1">{
                redactors[i] = NewRegexRedactor(pattern, `$1$2...&lt;REDACTED&gt;$7`)
        }</span>
        <span class="cov8" title="1">return &amp;RedactorChain{
                redactors: redactors,
        }</span>
}

func (rc *RedactorChain) AddRedactor(redactor Redactor) <span class="cov8" title="1">{
        rc.redactors = append(rc.redactors, redactor)
}</span>

func (rc *RedactorChain) Redact(input string) string <span class="cov8" title="1">{
        result := input
        for _, redactor := range rc.redactors </span><span class="cov8" title="1">{
                result = redactor.Redact(result)
        }</span>
        <span class="cov8" title="1">return result</span>
}

var DefaultAPIKeyPattern = regexp.MustCompile(`(?i)([?&amp;])((apiKey)(=)([a-z0-9]{7}))([^&amp;]+)`)

func RedactAPIKeys(input string) string <span class="cov8" title="1">{
        redactor := NewRegexRedactor(DefaultAPIKeyPattern, `$1$2...&lt;REDACTED&gt;$7`)
        return redactor.Redact(input)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package logging

import (
        "fmt"
        "log/slog"
        "sync"
)

// NamedHandlerFactory creates slog handlers with the given configuration.
type NamedHandlerFactory interface {
        // Name returns the unique name of this handler factory.
        Name() string

        // Create creates a new handler instance with the given configuration.
        Create(config interface{}) (slog.Handler, error)

        // ConfigType returns the expected configuration type for this factory.
        ConfigType() interface{}
}

// HandlerRegistry manages registered handler factories.
type HandlerRegistry struct {
        mu        sync.RWMutex
        factories map[string]NamedHandlerFactory
}

var (
        defaultRegistry = &amp;HandlerRegistry{
                factories: make(map[string]NamedHandlerFactory),
        }
)

// GetDefaultRegistry returns the default global handler registry.
func GetDefaultRegistry() *HandlerRegistry <span class="cov8" title="1">{
        return defaultRegistry
}</span>

// RegisterHandler registers a handler factory with the default registry.
func RegisterHandler(factory NamedHandlerFactory) error <span class="cov8" title="1">{
        return defaultRegistry.RegisterHandler(factory)
}</span>

// CreateHandler creates a handler using a registered factory from the default registry.
func CreateHandler(name string, config interface{}) (slog.Handler, error) <span class="cov8" title="1">{
        return defaultRegistry.CreateHandler(name, config)
}</span>

// ListHandlers returns all registered handler names from the default registry.
func ListHandlers() []string <span class="cov8" title="1">{
        return defaultRegistry.ListHandlers()
}</span>

// RegisterHandler registers a handler factory.
func (r *HandlerRegistry) RegisterHandler(factory NamedHandlerFactory) error <span class="cov8" title="1">{
        if factory == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("handler factory cannot be nil")
        }</span>

        <span class="cov8" title="1">name := factory.Name()
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("handler factory name cannot be empty")
        }</span>

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.factories[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("handler factory with name %q already registered", name)
        }</span>

        <span class="cov8" title="1">r.factories[name] = factory
        return nil</span>
}

// CreateHandler creates a handler using a registered factory.
func (r *HandlerRegistry) CreateHandler(name string, config interface{}) (slog.Handler, error) <span class="cov8" title="1">{
        r.mu.RLock()
        factory, exists := r.factories[name]
        r.mu.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no handler factory registered with name %q", name)
        }</span>

        <span class="cov8" title="1">return factory.Create(config)</span>
}

// GetFactory returns a registered handler factory by name.
func (r *HandlerRegistry) GetFactory(name string) (NamedHandlerFactory, bool) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        factory, exists := r.factories[name]
        return factory, exists
}</span>

// ListHandlers returns all registered handler names.
func (r *HandlerRegistry) ListHandlers() []string <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        names := make([]string, 0, len(r.factories))
        for name := range r.factories </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

// UnregisterHandler removes a handler factory from the registry.
func (r *HandlerRegistry) UnregisterHandler(name string) bool <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.factories[name]; !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">delete(r.factories, name)
        return true</span>
}

// Clear removes all registered handler factories.
func (r *HandlerRegistry) Clear() <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.factories = make(map[string]NamedHandlerFactory)
}</span>

// Built-in handler factories

// JSONHandlerFactory creates JSON handlers.
type JSONHandlerFactory struct{}

func (f *JSONHandlerFactory) Name() string <span class="cov8" title="1">{
        return "json"
}</span>

func (f *JSONHandlerFactory) ConfigType() interface{} <span class="cov8" title="1">{
        return &amp;OutputConfig{}
}</span>

func (f *JSONHandlerFactory) Create(config interface{}) (slog.Handler, error) <span class="cov8" title="1">{
        outputConfig, ok := config.(*OutputConfig)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected *OutputConfig, got %T", config)
        }</span>

        <span class="cov8" title="1">return slog.NewJSONHandler(outputConfig.Writer, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug, // Default level, can be overridden
        }), nil</span>
}

// TextHandlerFactory creates text handlers.
type TextHandlerFactory struct{}

func (f *TextHandlerFactory) Name() string <span class="cov8" title="1">{
        return "text"
}</span>

func (f *TextHandlerFactory) ConfigType() interface{} <span class="cov8" title="1">{
        return &amp;OutputConfig{}
}</span>

func (f *TextHandlerFactory) Create(config interface{}) (slog.Handler, error) <span class="cov8" title="1">{
        outputConfig, ok := config.(*OutputConfig)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected *OutputConfig, got %T", config)
        }</span>

        <span class="cov8" title="1">return slog.NewTextHandler(outputConfig.Writer, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug, // Default level, can be overridden
        }), nil</span>
}

// MultiHandlerFactory creates multi-output handlers.
type MultiHandlerFactory struct{}

func (f *MultiHandlerFactory) Name() string <span class="cov8" title="1">{
        return "multi"
}</span>

type MultiHandlerConfig struct {
        Handlers []slog.Handler
}

func (f *MultiHandlerFactory) ConfigType() interface{} <span class="cov0" title="0">{
        return &amp;MultiHandlerConfig{}
}</span>

func (f *MultiHandlerFactory) Create(config interface{}) (slog.Handler, error) <span class="cov0" title="0">{
        multiConfig, ok := config.(*MultiHandlerConfig)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected *MultiHandlerConfig, got %T", config)
        }</span>

        <span class="cov0" title="0">if len(multiConfig.Handlers) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multi handler requires at least one handler")
        }</span>

        <span class="cov0" title="0">return NewMultiHandler(multiConfig.Handlers...), nil</span>
}

// Initialize default handler factories
func init() <span class="cov8" title="1">{
        _ = RegisterHandler(&amp;JSONHandlerFactory{})
        _ = RegisterHandler(&amp;TextHandlerFactory{})
        _ = RegisterHandler(&amp;MultiHandlerFactory{})
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package logging provides structured logging with request tracing support.
package logging

import (
        "context"
)

type contextKey string

const (
        // TraceIDKey is the context key for trace identifiers that follow requests through the system.
        TraceIDKey contextKey = "trace_id"
        // RequestIDKey is the context key for unique request identifiers.
        RequestIDKey contextKey = "request_id"
        // CorrelationKey is the context key for correlation identifiers linking related requests.
        CorrelationKey contextKey = "correlation_id"
)

// NewTraceID generates a new unique trace identifier using the configured UUID generator.
// Use this to create trace IDs for tracking requests through your system.
//
// Example:
//
//        traceID := logging.NewTraceID()
//        ctx := logging.WithTraceID(context.Background(), traceID)
func NewTraceID() string <span class="cov8" title="1">{
        return defaultGenerator.Generate()
}</span>

// WithTraceID returns a new context with the trace ID attached.
// The trace ID can be retrieved later with GetTraceID.
//
// Example:
//
//        ctx := logging.WithTraceID(r.Context(), "trace-123")
//        logger.InfoContext(ctx, "Processing request")
func WithTraceID(ctx context.Context, traceID string) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, TraceIDKey, traceID)
}</span>

// GetTraceID retrieves the trace ID from the context.
// Returns the trace ID and true if present, empty string and false otherwise.
func GetTraceID(ctx context.Context) (string, bool) <span class="cov8" title="1">{
        traceID, ok := ctx.Value(TraceIDKey).(string)
        return traceID, ok
}</span>

// WithRequestID returns a new context with the request ID attached.
// The request ID can be retrieved later with GetRequestID.
func WithRequestID(ctx context.Context, requestID string) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, RequestIDKey, requestID)
}</span>

// GetRequestID retrieves the request ID from the context.
// Returns the request ID and true if present, empty string and false otherwise.
func GetRequestID(ctx context.Context) (string, bool) <span class="cov8" title="1">{
        requestID, ok := ctx.Value(RequestIDKey).(string)
        return requestID, ok
}</span>

// WithCorrelationID returns a new context with the correlation ID attached.
// The correlation ID can be retrieved later with GetCorrelationID.
// Use correlation IDs to link related requests across different services.
func WithCorrelationID(ctx context.Context, correlationID string) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, CorrelationKey, correlationID)
}</span>

// GetCorrelationID retrieves the correlation ID from the context.
// Returns the correlation ID and true if present, empty string and false otherwise.
func GetCorrelationID(ctx context.Context) (string, bool) <span class="cov8" title="1">{
        correlationID, ok := ctx.Value(CorrelationKey).(string)
        return correlationID, ok
}</span>

// NewContextWithTrace creates a new context with an automatically generated trace ID.
// This is a convenience function equivalent to WithTraceID(context.Background(), NewTraceID()).
//
// Example:
//
//        ctx := logging.NewContextWithTrace()
//        logger.InfoContext(ctx, "Starting new operation")
func NewContextWithTrace() context.Context <span class="cov8" title="1">{
        return WithTraceID(context.Background(), NewTraceID())
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package logging

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "log/slog"
        "runtime"
        "sync"
        "time"

        "github.com/ocrosby/go-logging/pkg/logging/internal"
)

// unifiedLogger is a single implementation that provides all logger interfaces
// and can adapt between standard Go logging and slog backends.
type unifiedLogger struct {
        mu            sync.RWMutex
        config        *LoggerConfig
        fields        map[string]interface{}
        textLoggers   map[Level]*log.Logger
        slogLogger    *slog.Logger
        discard       *log.Logger
        redactorChain RedactorChainInterface
}

// NewUnifiedLogger creates a new unified logger implementation.
func NewUnifiedLogger(config *LoggerConfig, redactorChain RedactorChainInterface) Logger <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = NewLoggerConfig().Build()
        }</span>
        <span class="cov8" title="1">if redactorChain == nil </span><span class="cov8" title="1">{
                redactorChain = NewRedactorChain()
        }</span>

        <span class="cov8" title="1">ul := &amp;unifiedLogger{
                config:        config,
                fields:        make(map[string]interface{}),
                textLoggers:   make(map[Level]*log.Logger),
                discard:       log.New(io.Discard, "", 0),
                redactorChain: redactorChain,
        }

        // Initialize based on configuration
        if config.UseSlog </span><span class="cov8" title="1">{
                handler := config.Handler
                if handler == nil </span><span class="cov8" title="1">{
                        if config.Formatter.Format == JSONFormat </span><span class="cov8" title="1">{
                                handler = slog.NewJSONHandler(config.Output.Writer, &amp;slog.HandlerOptions{
                                        Level: ul.levelToSlog(config.Core.Level),
                                })
                        }</span> else<span class="cov8" title="1"> {
                                handler = slog.NewTextHandler(config.Output.Writer, &amp;slog.HandlerOptions{
                                        Level: ul.levelToSlog(config.Core.Level),
                                })
                        }</span>
                }
                <span class="cov8" title="1">ul.slogLogger = slog.New(handler)</span>
        } else<span class="cov8" title="1"> if config.Formatter.Format == TextFormat </span><span class="cov8" title="1">{
                ul.initTextLoggers()
        }</span>

        <span class="cov8" title="1">return ul</span>
}

func (ul *unifiedLogger) initTextLoggers() <span class="cov8" title="1">{
        flags := 0
        if ul.config.Formatter.IncludeTime </span><span class="cov8" title="1">{
                flags |= log.LstdFlags | log.Lmsgprefix
        }</span>
        <span class="cov8" title="1">if ul.config.Formatter.IncludeFile </span><span class="cov8" title="1">{
                if ul.config.Formatter.UseShortFile </span><span class="cov8" title="1">{
                        flags |= log.Lshortfile
                }</span> else<span class="cov0" title="0"> {
                        flags |= log.Llongfile
                }</span>
        }

        <span class="cov8" title="1">for level := range levelNames </span><span class="cov8" title="1">{
                prefix := fmt.Sprintf("[%s] ", level)
                ul.textLoggers[level] = log.New(ul.config.Output.Writer, prefix, flags)
        }</span>
}

func (ul *unifiedLogger) levelToSlog(level Level) slog.Level <span class="cov8" title="1">{
        levelMap := map[Level]slog.Level{
                TraceLevel:    slog.Level(-8), // Custom trace level
                DebugLevel:    slog.LevelDebug,
                InfoLevel:     slog.LevelInfo,
                WarnLevel:     slog.LevelWarn,
                ErrorLevel:    slog.LevelError,
                CriticalLevel: slog.Level(12), // Custom critical level
        }

        if slogLevel, ok := levelMap[level]; ok </span><span class="cov8" title="1">{
                return slogLevel
        }</span>
        <span class="cov0" title="0">return slog.LevelInfo</span>
}

// Core Logger interface implementation
func (ul *unifiedLogger) Log(level Level, msg string, args ...interface{}) <span class="cov8" title="1">{
        ul.LogContext(context.Background(), level, msg, args...)
}</span>

func (ul *unifiedLogger) LogContext(ctx context.Context, level Level, msg string, args ...interface{}) <span class="cov8" title="1">{
        ul.mu.RLock()
        defer ul.mu.RUnlock()

        if !ul.isLevelEnabledInternal(level) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">message := fmt.Sprintf(msg, args...)
        message = ul.redactorChain.Redact(message)

        if ul.config.UseSlog </span><span class="cov8" title="1">{
                ul.logSlog(ctx, level, message)
        }</span> else<span class="cov8" title="1"> if ul.config.Formatter.Format == JSONFormat </span><span class="cov8" title="1">{
                ul.logJSON(level, message, ctx)
        }</span> else<span class="cov8" title="1"> {
                ul.logText(level, message)
        }</span>
}

func (ul *unifiedLogger) WithField(key string, value interface{}) Logger <span class="cov8" title="1">{
        ul.mu.RLock()
        newFields := make(map[string]interface{}, len(ul.fields)+1)
        for k, v := range ul.fields </span><span class="cov8" title="1">{
                newFields[k] = v
        }</span>
        <span class="cov8" title="1">ul.mu.RUnlock()

        newFields[key] = value

        return &amp;unifiedLogger{
                config:        ul.config,
                fields:        newFields,
                textLoggers:   ul.textLoggers,
                slogLogger:    ul.slogLogger,
                discard:       ul.discard,
                redactorChain: ul.redactorChain,
        }</span>
}

func (ul *unifiedLogger) WithFields(fields map[string]interface{}) Logger <span class="cov8" title="1">{
        ul.mu.RLock()
        newFields := make(map[string]interface{}, len(ul.fields)+len(fields))
        for k, v := range ul.fields </span><span class="cov8" title="1">{
                newFields[k] = v
        }</span>
        <span class="cov8" title="1">ul.mu.RUnlock()

        for k, v := range fields </span><span class="cov8" title="1">{
                newFields[k] = v
        }</span>

        <span class="cov8" title="1">return &amp;unifiedLogger{
                config:        ul.config,
                fields:        newFields,
                textLoggers:   ul.textLoggers,
                slogLogger:    ul.slogLogger,
                discard:       ul.discard,
                redactorChain: ul.redactorChain,
        }</span>
}

func (ul *unifiedLogger) IsLevelEnabled(level Level) bool <span class="cov8" title="1">{
        ul.mu.RLock()
        defer ul.mu.RUnlock()
        return ul.isLevelEnabledInternal(level)
}</span>

func (ul *unifiedLogger) isLevelEnabledInternal(level Level) bool <span class="cov8" title="1">{
        // When using slog, delegate to the slog handler for level checking
        if ul.config.UseSlog &amp;&amp; ul.slogLogger != nil </span><span class="cov8" title="1">{
                return ul.slogLogger.Enabled(context.Background(), ul.levelToSlog(level))
        }</span>
        // For standard logging, use config level
        <span class="cov8" title="1">return level &gt;= ul.config.Core.Level</span>
}

// LevelLogger interface implementation
func (ul *unifiedLogger) Trace(msg string, args ...interface{}) <span class="cov8" title="1">{
        ul.Log(TraceLevel, msg, args...)
}</span>

func (ul *unifiedLogger) Debug(msg string, args ...interface{}) <span class="cov8" title="1">{
        ul.Log(DebugLevel, msg, args...)
}</span>

func (ul *unifiedLogger) Info(msg string, args ...interface{}) <span class="cov8" title="1">{
        ul.Log(InfoLevel, msg, args...)
}</span>

func (ul *unifiedLogger) Warn(msg string, args ...interface{}) <span class="cov8" title="1">{
        ul.Log(WarnLevel, msg, args...)
}</span>

func (ul *unifiedLogger) Error(msg string, args ...interface{}) <span class="cov8" title="1">{
        ul.Log(ErrorLevel, msg, args...)
}</span>

func (ul *unifiedLogger) Critical(msg string, args ...interface{}) <span class="cov8" title="1">{
        ul.Log(CriticalLevel, msg, args...)
}</span>

// ContextLogger interface implementation
func (ul *unifiedLogger) TraceContext(ctx context.Context, msg string, args ...interface{}) <span class="cov0" title="0">{
        ul.LogContext(ctx, TraceLevel, msg, args...)
}</span>

func (ul *unifiedLogger) DebugContext(ctx context.Context, msg string, args ...interface{}) <span class="cov0" title="0">{
        ul.LogContext(ctx, DebugLevel, msg, args...)
}</span>

func (ul *unifiedLogger) InfoContext(ctx context.Context, msg string, args ...interface{}) <span class="cov8" title="1">{
        ul.LogContext(ctx, InfoLevel, msg, args...)
}</span>

func (ul *unifiedLogger) WarnContext(ctx context.Context, msg string, args ...interface{}) <span class="cov0" title="0">{
        ul.LogContext(ctx, WarnLevel, msg, args...)
}</span>

func (ul *unifiedLogger) ErrorContext(ctx context.Context, msg string, args ...interface{}) <span class="cov0" title="0">{
        ul.LogContext(ctx, ErrorLevel, msg, args...)
}</span>

func (ul *unifiedLogger) CriticalContext(ctx context.Context, msg string, args ...interface{}) <span class="cov0" title="0">{
        ul.LogContext(ctx, CriticalLevel, msg, args...)
}</span>

// ConfigurableLogger interface implementation
func (ul *unifiedLogger) SetLevel(level Level) <span class="cov8" title="1">{
        ul.mu.Lock()
        defer ul.mu.Unlock()
        ul.config.Core.Level = level
}</span>

func (ul *unifiedLogger) GetLevel() Level <span class="cov8" title="1">{
        ul.mu.RLock()
        defer ul.mu.RUnlock()
        return ul.config.Core.Level
}</span>

// FluentCapable interface implementation
func (ul *unifiedLogger) Fluent() FluentLogger <span class="cov8" title="1">{
        return &amp;fluentLoggerWrapper{logger: ul}
}</span>

// Internal logging methods
func (ul *unifiedLogger) logSlog(ctx context.Context, level Level, message string) <span class="cov8" title="1">{
        if ul.slogLogger == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">slogLevel := ul.levelToSlog(level)
        logAttrs := make([]slog.Attr, 0, len(ul.fields)+len(ul.config.Core.StaticFields)+1)

        // Add static fields
        for k, v := range ul.config.Core.StaticFields </span><span class="cov0" title="0">{
                logAttrs = append(logAttrs, slog.Any(k, v))
        }</span>

        // Add instance fields
        <span class="cov8" title="1">for k, v := range ul.fields </span><span class="cov8" title="1">{
                logAttrs = append(logAttrs, slog.Any(k, v))
        }</span>

        // Add context fields using the correct context keys
        <span class="cov8" title="1">if requestID, ok := GetRequestID(ctx); ok &amp;&amp; requestID != "" </span><span class="cov8" title="1">{
                logAttrs = append(logAttrs, slog.String("request_id", requestID))
        }</span>
        <span class="cov8" title="1">if traceID, ok := GetTraceID(ctx); ok &amp;&amp; traceID != "" </span><span class="cov0" title="0">{
                logAttrs = append(logAttrs, slog.String("trace_id", traceID))
        }</span>
        <span class="cov8" title="1">if correlationID, ok := GetCorrelationID(ctx); ok &amp;&amp; correlationID != "" </span><span class="cov0" title="0">{
                logAttrs = append(logAttrs, slog.String("correlation_id", correlationID))
        }</span>

        <span class="cov8" title="1">ul.slogLogger.LogAttrs(ctx, slogLevel, message, logAttrs...)</span>
}

func (ul *unifiedLogger) logText(level Level, message string) <span class="cov8" title="1">{
        logger := ul.textLoggers[level]
        if logger == nil </span><span class="cov0" title="0">{
                logger = ul.discard
        }</span>
        <span class="cov8" title="1">_ = logger.Output(3, message)</span>
}

func (ul *unifiedLogger) logJSON(level Level, message string, ctx context.Context) <span class="cov8" title="1">{
        entry := ul.createBaseEntry(level, message)
        ul.addFileInfo(entry)
        ul.addStaticFields(entry)
        ul.addInstanceFields(entry)
        ul.addContextFields(entry, ctx)
        ul.writeJSON(entry)
}</span>

func (ul *unifiedLogger) createBaseEntry(level Level, message string) map[string]interface{} <span class="cov8" title="1">{
        entry := make(map[string]interface{})

        if ul.config.Formatter.IncludeTime </span><span class="cov8" title="1">{
                entry["timestamp"] = time.Now().UTC().Format(time.RFC3339)
        }</span>

        <span class="cov8" title="1">entry["level"] = level.String()
        entry["message"] = message

        return entry</span>
}

func (ul *unifiedLogger) addFileInfo(entry map[string]interface{}) <span class="cov8" title="1">{
        if !ul.config.Formatter.IncludeFile </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if _, file, line, ok := runtime.Caller(4); ok </span><span class="cov8" title="1">{
                entry["file"] = ul.formatFilename(file, line)
        }</span>
}

func (ul *unifiedLogger) formatFilename(file string, line int) string <span class="cov8" title="1">{
        return internal.FormatFilename(file, line, ul.config.Formatter.UseShortFile)
}</span>

func (ul *unifiedLogger) addStaticFields(entry map[string]interface{}) <span class="cov8" title="1">{
        for k, v := range ul.config.Core.StaticFields </span><span class="cov0" title="0">{
                entry[k] = v
        }</span>
}

func (ul *unifiedLogger) addInstanceFields(entry map[string]interface{}) <span class="cov8" title="1">{
        for k, v := range ul.fields </span><span class="cov8" title="1">{
                entry[k] = v
        }</span>
}

func (ul *unifiedLogger) addContextFields(entry map[string]interface{}, ctx context.Context) <span class="cov8" title="1">{
        if requestID, ok := GetRequestID(ctx); ok &amp;&amp; requestID != "" </span><span class="cov8" title="1">{
                entry["request_id"] = requestID
        }</span>
        <span class="cov8" title="1">if traceID, ok := GetTraceID(ctx); ok &amp;&amp; traceID != "" </span><span class="cov8" title="1">{
                entry["trace_id"] = traceID
        }</span>
        <span class="cov8" title="1">if correlationID, ok := GetCorrelationID(ctx); ok &amp;&amp; correlationID != "" </span><span class="cov0" title="0">{
                entry["correlation_id"] = correlationID
        }</span>
}

func (ul *unifiedLogger) writeJSON(entry map[string]interface{}) <span class="cov8" title="1">{
        jsonBytes, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">fmt.Fprintln(ul.config.Output.Writer, string(jsonBytes))</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package logging

import (
        "crypto/rand"
        "fmt"
)

// UUIDGenerator defines the interface for generating unique identifiers.
// This allows users to provide custom UUID generation strategies.
type UUIDGenerator interface {
        // Generate creates a new UUID string
        Generate() string
}

// DefaultUUIDGenerator implements UUIDGenerator using crypto/rand with UUID v4 format.
// This is the default implementation that maintains backward compatibility.
type DefaultUUIDGenerator struct{}

// NewDefaultUUIDGenerator creates a new instance of DefaultUUIDGenerator.
func NewDefaultUUIDGenerator() *DefaultUUIDGenerator <span class="cov8" title="1">{
        return &amp;DefaultUUIDGenerator{}
}</span>

// Generate creates a new UUID v4 string using crypto/rand.
// This maintains the same behavior as the original NewTraceID function.
func (g *DefaultUUIDGenerator) Generate() string <span class="cov8" title="1">{
        var uuid [16]byte
        _, err := rand.Read(uuid[:])
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">uuid[6] = (uuid[6] &amp; 0x0f) | 0x40
        uuid[8] = (uuid[8] &amp; 0x3f) | 0x80
        return fmt.Sprintf("%x-%x-%x-%x-%x", uuid[0:4], uuid[4:6], uuid[6:8], uuid[8:10], uuid[10:])</span>
}

// defaultGenerator is the package-level default generator
var defaultGenerator UUIDGenerator = NewDefaultUUIDGenerator()

// SetUUIDGenerator sets the package-level UUID generator.
// This allows users to inject their own UUID generation strategy.
//
// Example:
//
//        logging.SetUUIDGenerator(&amp;MyCustomUUIDGenerator{})
func SetUUIDGenerator(generator UUIDGenerator) <span class="cov8" title="1">{
        if generator == nil </span><span class="cov8" title="1">{
                panic("UUID generator cannot be nil")</span>
        }
        <span class="cov8" title="1">defaultGenerator = generator</span>
}

// GetUUIDGenerator returns the current package-level UUID generator.
func GetUUIDGenerator() UUIDGenerator <span class="cov8" title="1">{
        return defaultGenerator
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
